\documentclass{article}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{multicol}
\usepackage{epsfig}
\textwidth 6in
\addtolength{\oddsidemargin}{-0.5in}
\textheight 9in
\addtolength{\topmargin}{-0.5in}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5cm}
\setlength{\columnsep}{5cm}
\topskip 0.0in
%\pagestyle{empty}
\thispagestyle{empty}
\title{Assignment 2}
\author{Satvik Chauhan (Y9521),Pankaj More (Y9402)}
%\date{August 04, 2004}
\date{}


\begin{document}
\maketitle
\section*{Simulation}
The Simulation part of the assignment was written in \textbf{Haskell} (pure functional programming language).Some of the implementation details are given below:
\begin{itemize}
\item We have used \textbf{State Monads} to simulate the machine.
\item A virtual machine is implemented which requires a scheduler to run.
\item The scheduler function requires the readyQueue and returns the pair (selected process,Alloted Burst time).
\item The Alloted burst time is same as the next CPU burst for all the schedulers except round robin.
\item The time quanta taken for round robin in 6 by default. It can be varied on users choice.
\item The parameters to generate the initial data are varied like heavy CPU bound processes or IO bound processes .
\item A assumption is made that the process starts with a CPU burst and ends with a CPU burst . So the number of CPU bursts is one more than the number of IO bursts.
\end{itemize}
We have written a python script to generate the distributions for inter arrival times , priority , IO and CPU bursts
\begin{itemize}
\item \textbf{Pankaj Report here the number of processes , poisson and exponential parameters and etc You have used.Write a make file if time permits}
\end{itemize}
We have drawn charts also using the \textbf{haskell chart library} .
We have shown the Bar graph comparison of average response , turnaround and waiting times for all the standard algorithms.To run use the following steps .
\begin{itemize}
\item python $seed\_data.py$
\item runhaskell $process.hs$
\item runhaskell $drawBar.hs$
\item runhaskell $drawBarP.hs$
\item runhaskell $drawChart.hs$
\end{itemize}
\begin{figure}[ht]
\centerline{\includegraphics[scale=1]{averages}}
\caption{{\it Averages . Preemptive sjf clearly perform better than others . Round robin has a good response time}}  
\label{surf}
\end{figure} 
Then we have shown the comparison of average response .waiting and turnaround times for three priority categories 
\begin{figure}[ht]
\centerline{\includegraphics[scale=1]{priority_response_averages}}
\caption{{\it Average Response time . It can be clearly seen that the average response time for priority 9 is zero for preemptive priority scheduling}}  
\label{surf}
\end{figure}
\begin{figure}[ht]
\centerline{\includegraphics[scale=1]{priority_turnaround_averages}}
\caption{{\it Average turnaround time. Again preemptive priority scheduling for priority 9 beats other}}  
\label{surf}
\end{figure}
\begin{figure}[ht]
\centerline{\includegraphics[scale=1]{priority_waiting_averages}}
\caption{{\it Average waiting time}}  
\label{surf}
\end{figure}
\end{document}