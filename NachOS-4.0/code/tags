!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	test/matmult.c	/^int A[Dim][Dim];$/;"	v
A	test/sort.c	/^int A[SIZE];	\/* size of physical memory; with code, we'll run out of space!*\/$/;"	v
ADDRSPACE_H	userprog/addrspace.h	14;"	d
ALARM_H	threads/alarm.h	18;"	d
AS	build.cygwin/Makefile	/^AS = as$/;"	m
AS	build.linux/Makefile	/^AS = as$/;"	m
AS	build.macosx/Makefile	/^AS = as$/;"	m
AS	test/Makefile	/^AS = $(GCCDIR)as$/;"	m
ASSERT	lib/debug.h	64;"	d
ASSERTNOTREACHED	lib/debug.h	80;"	d
Abort	lib/sysdep.cc	/^Abort()$/;"	f	signature:()
Abort	lib/sysdep.h	/^extern void Abort();$/;"	p	signature:()
Acquire	threads/synch.cc	/^void Lock::Acquire()$/;"	f	class:Lock	signature:()
Acquire	threads/synch.h	/^    void Acquire(); 		\/\/ these are the only operations on a lock$/;"	p	class:Lock	access:public	signature:()
Add	filesys/directory.cc	/^Directory::Add(char *name, int newSector)$/;"	f	class:Directory	signature:(char *name, int newSector)
Add	filesys/directory.h	/^    bool Add(char *name, int newSector);  \/\/ Add a file name into the directory$/;"	p	class:Directory	access:public	signature:(char *name, int newSector)
Add	test/start.S	/^Add:$/;"	l
Add	userprog/syscall.h	/^int Add(int op1, int op2);$/;"	p	signature:(int op1, int op2)
Add_Syscall	userprog/exception.cc	/^void Add_Syscall()$/;"	f	signature:()
AddrSpace	userprog/addrspace.cc	/^AddrSpace::AddrSpace()$/;"	f	class:AddrSpace	signature:()
AddrSpace	userprog/addrspace.h	/^    AddrSpace();			\/\/ Create an address space.$/;"	p	class:AddrSpace	access:public	signature:()
AddrSpace	userprog/addrspace.h	/^class AddrSpace {$/;"	c
AddrSpace::AddrSpace	userprog/addrspace.cc	/^AddrSpace::AddrSpace()$/;"	f	class:AddrSpace	signature:()
AddrSpace::AddrSpace	userprog/addrspace.h	/^    AddrSpace();			\/\/ Create an address space.$/;"	p	class:AddrSpace	access:public	signature:()
AddrSpace::Execute	userprog/addrspace.cc	/^AddrSpace::Execute() $/;"	f	class:AddrSpace	signature:()
AddrSpace::Execute	userprog/addrspace.h	/^    void Execute();             	\/\/ Run a program$/;"	p	class:AddrSpace	access:public	signature:()
AddrSpace::InitRegisters	userprog/addrspace.cc	/^AddrSpace::InitRegisters()$/;"	f	class:AddrSpace	signature:()
AddrSpace::InitRegisters	userprog/addrspace.h	/^    void InitRegisters();		\/\/ Initialize user-level CPU registers,$/;"	p	class:AddrSpace	access:private	signature:()
AddrSpace::Load	userprog/addrspace.cc	/^AddrSpace::Load(char *fileName) $/;"	f	class:AddrSpace	signature:(char *fileName)
AddrSpace::Load	userprog/addrspace.h	/^    bool Load(char *fileName);		\/\/ Load a program into addr space from$/;"	p	class:AddrSpace	access:public	signature:(char *fileName)
AddrSpace::RestoreState	userprog/addrspace.cc	/^void AddrSpace::RestoreState() $/;"	f	class:AddrSpace	signature:()
AddrSpace::RestoreState	userprog/addrspace.h	/^    void RestoreState();		\/\/ info on a context switch $/;"	p	class:AddrSpace	access:public	signature:()
AddrSpace::SaveState	userprog/addrspace.cc	/^void AddrSpace::SaveState() $/;"	f	class:AddrSpace	signature:()
AddrSpace::SaveState	userprog/addrspace.h	/^    void SaveState();			\/\/ Save\/restore address space-specific$/;"	p	class:AddrSpace	access:public	signature:()
AddrSpace::Translate	userprog/addrspace.cc	/^AddrSpace::Translate(unsigned int vaddr, unsigned int *paddr, int isReadWrite)$/;"	f	class:AddrSpace	signature:(unsigned int vaddr, unsigned int *paddr, int isReadWrite)
AddrSpace::Translate	userprog/addrspace.h	/^    ExceptionType Translate(unsigned int vaddr, unsigned int *paddr, int mode);$/;"	p	class:AddrSpace	access:public	signature:(unsigned int vaddr, unsigned int *paddr, int mode)
AddrSpace::numPages	userprog/addrspace.h	/^    unsigned int numPages;		\/\/ Number of pages in the virtual $/;"	m	class:AddrSpace	access:private
AddrSpace::pageTable	userprog/addrspace.h	/^    TranslationEntry *pageTable;	\/\/ Assume linear page table translation$/;"	m	class:AddrSpace	access:private
AddrSpace::~AddrSpace	userprog/addrspace.cc	/^AddrSpace::~AddrSpace()$/;"	f	class:AddrSpace	signature:()
AddrSpace::~AddrSpace	userprog/addrspace.h	/^    ~AddrSpace();			\/\/ De-allocate an address space$/;"	p	class:AddrSpace	access:public	signature:()
AddressErrorException	machine/machine.h	/^		     AddressErrorException, \/\/ Unaligned reference or one that$/;"	e	enum:ExceptionType
Alarm	threads/alarm.cc	/^Alarm::Alarm(bool doRandom)$/;"	f	class:Alarm	signature:(bool doRandom)
Alarm	threads/alarm.h	/^    Alarm(bool doRandomYield);	\/\/ Initialize the timer, and callback $/;"	p	class:Alarm	access:public	signature:(bool doRandomYield)
Alarm	threads/alarm.h	/^class Alarm : public CallBackObj {$/;"	c	inherits:CallBackObj
Alarm::Alarm	threads/alarm.cc	/^Alarm::Alarm(bool doRandom)$/;"	f	class:Alarm	signature:(bool doRandom)
Alarm::Alarm	threads/alarm.h	/^    Alarm(bool doRandomYield);	\/\/ Initialize the timer, and callback $/;"	p	class:Alarm	access:public	signature:(bool doRandomYield)
Alarm::CallBack	threads/alarm.cc	/^Alarm::CallBack() $/;"	f	class:Alarm	signature:()
Alarm::CallBack	threads/alarm.h	/^    void CallBack();		\/\/ called when the hardware$/;"	p	class:Alarm	access:private	signature:()
Alarm::WaitUntil	threads/alarm.h	/^    void WaitUntil(int x);	\/\/ suspend execution until time > now + x$/;"	p	class:Alarm	access:public	signature:(int x)
Alarm::timer	threads/alarm.h	/^    Timer *timer;		\/\/ the hardware timer device$/;"	m	class:Alarm	access:private
Alarm::~Alarm	threads/alarm.h	/^    ~Alarm() { delete timer; }$/;"	f	class:Alarm	access:public	signature:()
AllocBoundedArray	lib/sysdep.cc	/^AllocBoundedArray(int size)$/;"	f	signature:(int size)
AllocBoundedArray	lib/sysdep.h	/^extern char *AllocBoundedArray(int size);$/;"	p	signature:(int size)
Allocate	filesys/filehdr.cc	/^FileHeader::Allocate(PersistentBitmap *freeMap, int fileSize)$/;"	f	class:FileHeader	signature:(PersistentBitmap *freeMap, int fileSize)
Allocate	filesys/filehdr.h	/^    bool Allocate(PersistentBitmap *bitMap, int fileSize);\/\/ Initialize a file header, $/;"	p	class:FileHeader	access:public	signature:(PersistentBitmap *bitMap, int fileSize)
Append	lib/list.cc	/^List<T>::Append(T item)$/;"	f	class:List	signature:(T item)
Append	lib/list.h	/^    virtual void Append(T item); \/\/ Put item at the end of the list$/;"	p	class:List	access:public	signature:(T item)
Append	lib/list.h	/^    void Append(T item) { Insert(item); }   \/\/ neither does *ap*pend $/;"	f	class:SortedList	access:private	signature:(T item)
Append	threads/synchlist.cc	/^SynchList<T>::Append(T item)$/;"	f	class:SynchList	signature:(T item)
Append	threads/synchlist.h	/^    void Append(T item);	\/\/ append item to the end of the list,$/;"	p	class:SynchList	access:public	signature:(T item)
Apply	lib/hash.cc	/^HashTable<Key,T>::Apply(void (*func)(T)) const$/;"	f	class:HashTable	signature:(void (*func)(T)) const
Apply	lib/hash.h	/^    void Apply(void (*f)(T)) const;$/;"	p	class:HashTable	access:public	signature:(void (*f)(T)) const
Apply	lib/list.cc	/^List<T>::Apply(void (*func)(T)) const$/;"	f	class:List	signature:(void (*func)(T)) const
Apply	lib/list.h	/^    void Apply(void (*f)(T)) const; $/;"	p	class:List	access:public	signature:(void (*f)(T)) const
Apply	threads/synchlist.cc	/^SynchList<T>::Apply(void (*func)(T))$/;"	f	class:SynchList	signature:(void (*func)(T))
Apply	threads/synchlist.h	/^    void Apply(void (*f)(T)); \/\/ apply function to all elements in list$/;"	p	class:SynchList	access:public	signature:(void (*f)(T))
AssignNameToSocket	lib/sysdep.cc	/^AssignNameToSocket(char *socketName, int sockID)$/;"	f	signature:(char *socketName, int sockID)
AssignNameToSocket	lib/sysdep.h	/^extern void AssignNameToSocket(char *socketName, int sockID);$/;"	p	signature:(char *socketName, int sockID)
B	test/matmult.c	/^int B[Dim][Dim];$/;"	v
BCOND	machine/mipssim.h	106;"	d
BITMAP_H	lib/bitmap.h	16;"	d
BLOCKED	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
BadVAddrReg	machine/machine.h	74;"	d
Begin	threads/thread.cc	/^Thread::Begin ()$/;"	f	class:Thread	signature:()
Begin	threads/thread.h	/^    void Begin();		\/\/ Startup code for the thread	$/;"	p	class:Thread	access:public	signature:()
Bitmap	lib/bitmap.cc	/^Bitmap::Bitmap(int numItems) $/;"	f	class:Bitmap	signature:(int numItems)
Bitmap	lib/bitmap.h	/^    Bitmap(int numItems);	\/\/ Initialize a bitmap, with "numItems" bits$/;"	p	class:Bitmap	access:public	signature:(int numItems)
Bitmap	lib/bitmap.h	/^class Bitmap {$/;"	c
Bitmap::Bitmap	lib/bitmap.cc	/^Bitmap::Bitmap(int numItems) $/;"	f	class:Bitmap	signature:(int numItems)
Bitmap::Bitmap	lib/bitmap.h	/^    Bitmap(int numItems);	\/\/ Initialize a bitmap, with "numItems" bits$/;"	p	class:Bitmap	access:public	signature:(int numItems)
Bitmap::Clear	lib/bitmap.cc	/^Bitmap::Clear(int which) $/;"	f	class:Bitmap	signature:(int which)
Bitmap::Clear	lib/bitmap.h	/^    void Clear(int which);  	\/\/ Clear the "nth" bit$/;"	p	class:Bitmap	access:public	signature:(int which)
Bitmap::FindAndSet	lib/bitmap.cc	/^Bitmap::FindAndSet() $/;"	f	class:Bitmap	signature:()
Bitmap::FindAndSet	lib/bitmap.h	/^    int FindAndSet();         \/\/ Return the # of a clear bit, and as a side$/;"	p	class:Bitmap	access:public	signature:()
Bitmap::Mark	lib/bitmap.cc	/^Bitmap::Mark(int which) $/;"	f	class:Bitmap	signature:(int which)
Bitmap::Mark	lib/bitmap.h	/^    void Mark(int which);   	\/\/ Set the "nth" bit$/;"	p	class:Bitmap	access:public	signature:(int which)
Bitmap::NumClear	lib/bitmap.cc	/^Bitmap::NumClear() const$/;"	f	class:Bitmap	signature:() const
Bitmap::NumClear	lib/bitmap.h	/^    int NumClear() const;	\/\/ Return the number of clear bits$/;"	p	class:Bitmap	access:public	signature:() const
Bitmap::Print	lib/bitmap.cc	/^Bitmap::Print() const$/;"	f	class:Bitmap	signature:() const
Bitmap::Print	lib/bitmap.h	/^    void Print() const;		\/\/ Print contents of bitmap$/;"	p	class:Bitmap	access:public	signature:() const
Bitmap::SelfTest	lib/bitmap.cc	/^Bitmap::SelfTest() $/;"	f	class:Bitmap	signature:()
Bitmap::SelfTest	lib/bitmap.h	/^    void SelfTest();		\/\/ Test whether bitmap is working$/;"	p	class:Bitmap	access:public	signature:()
Bitmap::Test	lib/bitmap.cc	/^Bitmap::Test(int which) const$/;"	f	class:Bitmap	signature:(int which) const
Bitmap::Test	lib/bitmap.h	/^    bool Test(int which) const;	\/\/ Is the "nth" bit set?$/;"	p	class:Bitmap	access:public	signature:(int which) const
Bitmap::map	lib/bitmap.h	/^    unsigned int *map;		\/\/ bit storage$/;"	m	class:Bitmap	access:protected
Bitmap::numBits	lib/bitmap.h	/^    int numBits;		\/\/ number of bits in the bitmap$/;"	m	class:Bitmap	access:protected
Bitmap::numWords	lib/bitmap.h	/^    int numWords;		\/\/ number of words of bitmap storage$/;"	m	class:Bitmap	access:protected
Bitmap::~Bitmap	lib/bitmap.cc	/^Bitmap::~Bitmap()$/;"	f	class:Bitmap	signature:()
Bitmap::~Bitmap	lib/bitmap.h	/^    ~Bitmap();			\/\/ De-allocate bitmap$/;"	p	class:Bitmap	access:public	signature:()
BitsInByte	lib/bitmap.h	/^const int BitsInByte =	8;$/;"	v
BitsInWord	lib/bitmap.h	/^const int BitsInWord = sizeof(unsigned int) * BitsInByte;$/;"	v
Broadcast	threads/synch.cc	/^void Condition::Broadcast(Lock* conditionLock) $/;"	f	class:Condition	signature:(Lock* conditionLock)
Broadcast	threads/synch.h	/^    void Broadcast(Lock *conditionLock);\/\/ the currentThread for all of $/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
Bucket	lib/hash.h	/^typedef List<T> *Bucket;$/;"	t	class:HashTable	access:private
BusErrorException	machine/machine.h	/^		     BusErrorException,     \/\/ Translation resulted in an $/;"	e	enum:ExceptionType
ByteToSector	filesys/filehdr.cc	/^FileHeader::ByteToSector(int offset)$/;"	f	class:FileHeader	signature:(int offset)
ByteToSector	filesys/filehdr.h	/^    int ByteToSector(int offset);	\/\/ Convert a byte offset into the file$/;"	p	class:FileHeader	access:public	signature:(int offset)
C	test/matmult.c	/^int C[Dim][Dim];$/;"	v
CALLBACK_H	machine/callback.h	27;"	d
CC	build.cygwin/Makefile	/^CC = g++$/;"	m
CC	build.linux/Makefile	/^CC = g++$/;"	m
CC	build.macosx/Makefile	/^CC = g++$/;"	m
CC	test/Makefile	/^CC = $(GCCDIR)gcc$/;"	m
CFILES	build.cygwin/Makefile	/^CFILES = $(LIB_C) $(MACHINE_C) $(THREAD_C) $(USERPROG_C) $(FILESYS_C) $(NETWORK_C)$/;"	m
CFILES	build.linux/Makefile	/^CFILES = $(LIB_C) $(MACHINE_C) $(THREAD_C) $(USERPROG_C) $(FILESYS_C) $(NETWORK_C)$/;"	m
CFILES	build.macosx/Makefile	/^CFILES = $(LIB_C) $(MACHINE_C) $(THREAD_C) $(USERPROG_C) $(FILESYS_C) $(NETWORK_C)$/;"	m
CFLAGS	build.cygwin/Makefile	/^CFLAGS = -g -Wall -fwritable-strings $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED$/;"	m
CFLAGS	build.linux/Makefile	/^CFLAGS = -g -Wall $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED -m32$/;"	m
CFLAGS	build.macosx/Makefile	/^CFLAGS = -g -Wall -fwritable-strings $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED$/;"	m
CFLAGS	test/Makefile	/^CFLAGS = -G 0 -c $(INCDIR) -B..\/..\/..\/usr\/local\/nachos\/lib\/gcc-lib\/decstation-ultrix\/2.95.2\/ -B..\/..\/..\/usr\/local\/nachos\/decstation-ultrix\/bin\/$/;"	m
CONSOLE_H	machine/console.h	28;"	d
CPP	build.cygwin/Makefile	/^CPP= cpp$/;"	m
CPP	build.linux/Makefile	/^CPP=\/lib\/cpp$/;"	m
CPP	build.macosx/Makefile	/^CPP=\/lib\/cpp$/;"	m
CPP_AS_FLAGS	build.linux/Makefile	/^CPP_AS_FLAGS = -m32$/;"	m
CR	threads/switch.h	203;"	d
C_OFILES	build.cygwin/Makefile	/^C_OFILES = $(LIB_O) $(MACHINE_O) $(THREAD_O) $(USERPROG_O) $(FILESYS_O) $(NETWORK_O)$/;"	m
C_OFILES	build.linux/Makefile	/^C_OFILES = $(LIB_O) $(MACHINE_O) $(THREAD_O) $(USERPROG_O) $(FILESYS_O) $(NETWORK_O)$/;"	m
C_OFILES	build.macosx/Makefile	/^C_OFILES = $(LIB_O) $(MACHINE_O) $(THREAD_O) $(USERPROG_O) $(FILESYS_O) $(NETWORK_O)$/;"	m
CallBack	filesys/synchdisk.cc	/^SynchDisk::CallBack()$/;"	f	class:SynchDisk	signature:()
CallBack	filesys/synchdisk.h	/^    void CallBack();			\/\/ Called by the disk device interrupt$/;"	p	class:SynchDisk	access:public	signature:()
CallBack	machine/callback.h	/^     virtual void CallBack() = 0;$/;"	p	class:CallBackObj	access:public	signature:()
CallBack	machine/console.cc	/^ConsoleInput::CallBack()$/;"	f	class:ConsoleInput	signature:()
CallBack	machine/console.cc	/^ConsoleOutput::CallBack()$/;"	f	class:ConsoleOutput	signature:()
CallBack	machine/console.h	/^    void CallBack();		\/\/ Invoked when a character arrives$/;"	p	class:ConsoleInput	access:public	signature:()
CallBack	machine/console.h	/^    void CallBack();		\/\/ Invoked when next character can be put$/;"	p	class:ConsoleOutput	access:public	signature:()
CallBack	machine/disk.cc	/^Disk::CallBack ()$/;"	f	class:Disk	signature:()
CallBack	machine/disk.h	/^    void CallBack();			\/\/ Invoked when disk request $/;"	p	class:Disk	access:public	signature:()
CallBack	machine/network.cc	/^NetworkInput::CallBack()$/;"	f	class:NetworkInput	signature:()
CallBack	machine/network.cc	/^NetworkOutput::CallBack()$/;"	f	class:NetworkOutput	signature:()
CallBack	machine/network.h	/^    void CallBack();		\/\/ A packet may have arrived.$/;"	p	class:NetworkInput	access:public	signature:()
CallBack	machine/network.h	/^    void CallBack();		\/\/ Interrupt handler, called when message is $/;"	p	class:NetworkOutput	access:public	signature:()
CallBack	machine/timer.cc	/^Timer::CallBack() $/;"	f	class:Timer	signature:()
CallBack	machine/timer.h	/^    void CallBack();		\/\/ called internally when the hardware$/;"	p	class:Timer	access:private	signature:()
CallBack	network/post.cc	/^PostOfficeInput::CallBack()$/;"	f	class:PostOfficeInput	signature:()
CallBack	network/post.cc	/^PostOfficeOutput::CallBack()$/;"	f	class:PostOfficeOutput	signature:()
CallBack	network/post.h	/^    void CallBack();		\/\/ Called when incoming packet has arrived $/;"	p	class:PostOfficeInput	access:public	signature:()
CallBack	network/post.h	/^    void CallBack();		\/\/ Called when outgoing packet has been $/;"	p	class:PostOfficeOutput	access:public	signature:()
CallBack	threads/alarm.cc	/^Alarm::CallBack() $/;"	f	class:Alarm	signature:()
CallBack	threads/alarm.h	/^    void CallBack();		\/\/ called when the hardware$/;"	p	class:Alarm	access:private	signature:()
CallBack	userprog/synchconsole.cc	/^SynchConsoleInput::CallBack()$/;"	f	class:SynchConsoleInput	signature:()
CallBack	userprog/synchconsole.cc	/^SynchConsoleOutput::CallBack()$/;"	f	class:SynchConsoleOutput	signature:()
CallBack	userprog/synchconsole.h	/^    void CallBack();		\/\/ called when a keystroke is available$/;"	p	class:SynchConsoleInput	access:private	signature:()
CallBack	userprog/synchconsole.h	/^    void CallBack();		\/\/ called when more data can be written$/;"	p	class:SynchConsoleOutput	access:private	signature:()
CallBackObj	machine/callback.h	/^     CallBackObj() {};	\/\/ to prevent anyone from creating$/;"	f	class:CallBackObj	access:protected	signature:()
CallBackObj	machine/callback.h	/^class CallBackObj {$/;"	c
CallBackObj::CallBack	machine/callback.h	/^     virtual void CallBack() = 0;$/;"	p	class:CallBackObj	access:public	signature:()
CallBackObj::CallBackObj	machine/callback.h	/^     CallBackObj() {};	\/\/ to prevent anyone from creating$/;"	f	class:CallBackObj	access:protected	signature:()
CallBackObj::~CallBackObj	machine/callback.h	/^     virtual ~CallBackObj() {};$/;"	f	class:CallBackObj	access:protected	signature:()
CallOnUserAbort	lib/sysdep.cc	/^CallOnUserAbort(void (*func)(int))$/;"	f	signature:(void (*func)(int))
CallOnUserAbort	lib/sysdep.h	/^extern void CallOnUserAbort(void (*cleanup)(int));$/;"	p	signature:(void (*cleanup)(int))
ChangeLevel	machine/interrupt.cc	/^Interrupt::ChangeLevel(IntStatus old, IntStatus now)$/;"	f	class:Interrupt	signature:(IntStatus old, IntStatus now)
ChangeLevel	machine/interrupt.h	/^    void ChangeLevel(IntStatus old, 	\/\/ SetLevel, without advancing the$/;"	p	class:Interrupt	access:private	signature:(IntStatus old, IntStatus now)
CheckEndian	machine/machine.cc	/^void CheckEndian()$/;"	f	file:	signature:()
CheckIfDue	machine/interrupt.cc	/^Interrupt::CheckIfDue(bool advanceClock)$/;"	f	class:Interrupt	signature:(bool advanceClock)
CheckIfDue	machine/interrupt.h	/^    bool CheckIfDue(bool advanceClock); $/;"	p	class:Interrupt	access:private	signature:(bool advanceClock)
CheckOverflow	threads/thread.cc	/^Thread::CheckOverflow()$/;"	f	class:Thread	signature:()
CheckOverflow	threads/thread.h	/^    void CheckOverflow();   	\/\/ Check if thread stack has overflowed$/;"	p	class:Thread	access:public	signature:()
CheckToBeDestroyed	threads/scheduler.cc	/^Scheduler::CheckToBeDestroyed()$/;"	f	class:Scheduler	signature:()
CheckToBeDestroyed	threads/scheduler.h	/^    void CheckToBeDestroyed();\/\/ Check if thread that had been$/;"	p	class:Scheduler	access:public	signature:()
Cleanup	threads/main.cc	/^Cleanup(int x) $/;"	f	file:	signature:(int x)
Clear	lib/bitmap.cc	/^Bitmap::Clear(int which) $/;"	f	class:Bitmap	signature:(int which)
Clear	lib/bitmap.h	/^    void Clear(int which);  	\/\/ Clear the "nth" bit$/;"	p	class:Bitmap	access:public	signature:(int which)
Close	lib/sysdep.cc	/^Close(int fd)$/;"	f	signature:(int fd)
Close	lib/sysdep.h	/^extern int Close(int fd);$/;"	p	signature:(int fd)
Close	test/start.S	/^Close:$/;"	l
Close	userprog/syscall.h	/^int Close(OpenFileId id);$/;"	p	signature:(OpenFileId id)
CloseSocket	lib/sysdep.cc	/^CloseSocket(int sockID)$/;"	f	signature:(int sockID)
CloseSocket	lib/sysdep.h	/^extern void CloseSocket(int sockID);$/;"	p	signature:(int sockID)
ComputeLatency	machine/disk.cc	/^Disk::ComputeLatency(int newSector, bool writing)$/;"	f	class:Disk	signature:(int newSector, bool writing)
ComputeLatency	machine/disk.h	/^    int ComputeLatency(int newSector, bool writing);	$/;"	p	class:Disk	access:public	signature:(int newSector, bool writing)
Condition	threads/synch.cc	/^Condition::Condition(char* debugName)$/;"	f	class:Condition	signature:(char* debugName)
Condition	threads/synch.h	/^    Condition(char* debugName);	\/\/ initialize condition to $/;"	p	class:Condition	access:public	signature:(char* debugName)
Condition	threads/synch.h	/^class Condition {$/;"	c
Condition::Broadcast	threads/synch.cc	/^void Condition::Broadcast(Lock* conditionLock) $/;"	f	class:Condition	signature:(Lock* conditionLock)
Condition::Broadcast	threads/synch.h	/^    void Broadcast(Lock *conditionLock);\/\/ the currentThread for all of $/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
Condition::Condition	threads/synch.cc	/^Condition::Condition(char* debugName)$/;"	f	class:Condition	signature:(char* debugName)
Condition::Condition	threads/synch.h	/^    Condition(char* debugName);	\/\/ initialize condition to $/;"	p	class:Condition	access:public	signature:(char* debugName)
Condition::Signal	threads/synch.cc	/^void Condition::Signal(Lock* conditionLock)$/;"	f	class:Condition	signature:(Lock* conditionLock)
Condition::Signal	threads/synch.h	/^    void Signal(Lock *conditionLock);   \/\/ conditionLock must be held by$/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
Condition::Wait	threads/synch.cc	/^void Condition::Wait(Lock* conditionLock) $/;"	f	class:Condition	signature:(Lock* conditionLock)
Condition::Wait	threads/synch.h	/^    void Wait(Lock *conditionLock); 	\/\/ these are the 3 operations on $/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
Condition::getName	threads/synch.h	/^    char* getName() { return (name); }$/;"	f	class:Condition	access:public	signature:()
Condition::name	threads/synch.h	/^    char* name;$/;"	m	class:Condition	access:private
Condition::waitQueue	threads/synch.h	/^    List<Semaphore *> *waitQueue;	\/\/ list of waiting threads$/;"	m	class:Condition	access:private
Condition::~Condition	threads/synch.cc	/^Condition::~Condition()$/;"	f	class:Condition	signature:()
Condition::~Condition	threads/synch.h	/^    ~Condition();			\/\/ deallocate the condition$/;"	p	class:Condition	access:public	signature:()
ConsoleInput	machine/console.cc	/^ConsoleInput::ConsoleInput(char *readFile, CallBackObj *toCall)$/;"	f	class:ConsoleInput	signature:(char *readFile, CallBackObj *toCall)
ConsoleInput	machine/console.h	/^    ConsoleInput(char *readFile, CallBackObj *toCall);$/;"	p	class:ConsoleInput	access:public	signature:(char *readFile, CallBackObj *toCall)
ConsoleInput	machine/console.h	/^class ConsoleInput : public CallBackObj {$/;"	c	inherits:CallBackObj
ConsoleInput	userprog/syscall.h	108;"	d
ConsoleInput::CallBack	machine/console.cc	/^ConsoleInput::CallBack()$/;"	f	class:ConsoleInput	signature:()
ConsoleInput::CallBack	machine/console.h	/^    void CallBack();		\/\/ Invoked when a character arrives$/;"	p	class:ConsoleInput	access:public	signature:()
ConsoleInput::ConsoleInput	machine/console.cc	/^ConsoleInput::ConsoleInput(char *readFile, CallBackObj *toCall)$/;"	f	class:ConsoleInput	signature:(char *readFile, CallBackObj *toCall)
ConsoleInput::ConsoleInput	machine/console.h	/^    ConsoleInput(char *readFile, CallBackObj *toCall);$/;"	p	class:ConsoleInput	access:public	signature:(char *readFile, CallBackObj *toCall)
ConsoleInput::GetChar	machine/console.cc	/^ConsoleInput::GetChar()$/;"	f	class:ConsoleInput	signature:()
ConsoleInput::GetChar	machine/console.h	/^    char GetChar();	   	\/\/ Poll the console input.  If a char is $/;"	p	class:ConsoleInput	access:public	signature:()
ConsoleInput::callWhenAvail	machine/console.h	/^    CallBackObj *callWhenAvail;		\/\/ Interrupt handler to call when $/;"	m	class:ConsoleInput	access:private
ConsoleInput::incoming	machine/console.h	/^    char incoming;    			\/\/ Contains the character to be read,$/;"	m	class:ConsoleInput	access:private
ConsoleInput::readFileNo	machine/console.h	/^    int readFileNo;			\/\/ UNIX file emulating the keyboard $/;"	m	class:ConsoleInput	access:private
ConsoleInput::~ConsoleInput	machine/console.cc	/^ConsoleInput::~ConsoleInput()$/;"	f	class:ConsoleInput	signature:()
ConsoleInput::~ConsoleInput	machine/console.h	/^    ~ConsoleInput();		\/\/ clean up console emulation$/;"	p	class:ConsoleInput	access:public	signature:()
ConsoleOutput	machine/console.cc	/^ConsoleOutput::ConsoleOutput(char *writeFile, CallBackObj *toCall)$/;"	f	class:ConsoleOutput	signature:(char *writeFile, CallBackObj *toCall)
ConsoleOutput	machine/console.h	/^    ConsoleOutput(char *writeFile, CallBackObj *toCall);$/;"	p	class:ConsoleOutput	access:public	signature:(char *writeFile, CallBackObj *toCall)
ConsoleOutput	machine/console.h	/^class ConsoleOutput : public CallBackObj {$/;"	c	inherits:CallBackObj
ConsoleOutput	userprog/syscall.h	109;"	d
ConsoleOutput::CallBack	machine/console.cc	/^ConsoleOutput::CallBack()$/;"	f	class:ConsoleOutput	signature:()
ConsoleOutput::CallBack	machine/console.h	/^    void CallBack();		\/\/ Invoked when next character can be put$/;"	p	class:ConsoleOutput	access:public	signature:()
ConsoleOutput::ConsoleOutput	machine/console.cc	/^ConsoleOutput::ConsoleOutput(char *writeFile, CallBackObj *toCall)$/;"	f	class:ConsoleOutput	signature:(char *writeFile, CallBackObj *toCall)
ConsoleOutput::ConsoleOutput	machine/console.h	/^    ConsoleOutput(char *writeFile, CallBackObj *toCall);$/;"	p	class:ConsoleOutput	access:public	signature:(char *writeFile, CallBackObj *toCall)
ConsoleOutput::PutChar	machine/console.cc	/^ConsoleOutput::PutChar(char ch)$/;"	f	class:ConsoleOutput	signature:(char ch)
ConsoleOutput::PutChar	machine/console.h	/^    void PutChar(char ch);	\/\/ Write "ch" to the console display, $/;"	p	class:ConsoleOutput	access:public	signature:(char ch)
ConsoleOutput::callWhenDone	machine/console.h	/^    CallBackObj *callWhenDone;		\/\/ Interrupt handler to call when $/;"	m	class:ConsoleOutput	access:private
ConsoleOutput::putBusy	machine/console.h	/^    bool putBusy;    			\/\/ Is a PutChar operation in progress?$/;"	m	class:ConsoleOutput	access:private
ConsoleOutput::writeFileNo	machine/console.h	/^    int writeFileNo;			\/\/ UNIX file emulating the display$/;"	m	class:ConsoleOutput	access:private
ConsoleOutput::~ConsoleOutput	machine/console.cc	/^ConsoleOutput::~ConsoleOutput()$/;"	f	class:ConsoleOutput	signature:()
ConsoleOutput::~ConsoleOutput	machine/console.h	/^    ~ConsoleOutput();		\/\/ clean up console emulation$/;"	p	class:ConsoleOutput	access:public	signature:()
ConsoleReadInt	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	e	enum:IntType
ConsoleTest	threads/kernel.cc	/^Kernel::ConsoleTest() {$/;"	f	class:Kernel	signature:()
ConsoleTest	threads/kernel.h	/^    void ConsoleTest();         \/\/ interactive console self test$/;"	p	class:Kernel	access:public	signature:()
ConsoleTime	machine/stats.h	/^const int ConsoleTime =	 100;	\/\/ time to read or write one character$/;"	v
ConsoleWriteInt	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	e	enum:IntType
Copy	threads/main.cc	/^Copy(char *from, char *to)$/;"	f	file:	signature:(char *from, char *to)
Create	filesys/filesys.cc	/^FileSystem::Create(char *name, int initialSize)$/;"	f	class:FileSystem	signature:(char *name, int initialSize)
Create	filesys/filesys.h	/^    bool Create(char *name) {$/;"	f	class:FileSystem	access:public	signature:(char *name)
Create	filesys/filesys.h	/^    bool Create(char *name, int initialSize);  	$/;"	p	class:FileSystem	access:public	signature:(char *name, int initialSize)
Create	test/start.S	/^Create:$/;"	l
Create	userprog/syscall.h	/^int Create(char *name);$/;"	p	signature:(char *name)
DEBUG	lib/debug.h	50;"	d
DEBUG_H	lib/debug.h	14;"	d
DEFINES	build.cygwin/Makefile	/^DEFINES =  -DFILESYS_STUB -DRDATA -DSIM_FIX$/;"	m
DEFINES	build.linux/Makefile	/^DEFINES =  -DFILESYS_STUB -DRDATA -DSIM_FIX$/;"	m
DEFINES	build.macosx/Makefile	/^DEFINES =  -DFILESYS_STUB -DRDATA -DSIM_FIX$/;"	m
DIRECTORY_H	filesys/directory.h	18;"	d
DISK_H	machine/disk.h	18;"	d
DeAssignNameToSocket	lib/sysdep.cc	/^DeAssignNameToSocket(char *socketName)$/;"	f	signature:(char *socketName)
DeAssignNameToSocket	lib/sysdep.h	/^extern void DeAssignNameToSocket(char *socketName);$/;"	p	signature:(char *socketName)
DeallocBoundedArray	lib/sysdep.cc	/^DeallocBoundedArray(char *ptr, int \/* size *\/)$/;"	f	signature:(char *ptr, int )
DeallocBoundedArray	lib/sysdep.cc	/^DeallocBoundedArray(char *ptr, int size)$/;"	f	signature:(char *ptr, int size)
DeallocBoundedArray	lib/sysdep.h	/^extern void DeallocBoundedArray(char *p, int size);$/;"	p	signature:(char *p, int size)
Deallocate	filesys/filehdr.cc	/^FileHeader::Deallocate(PersistentBitmap *freeMap)$/;"	f	class:FileHeader	signature:(PersistentBitmap *freeMap)
Deallocate	filesys/filehdr.h	/^    void Deallocate(PersistentBitmap *bitMap);  \/\/ De-allocate this file's $/;"	p	class:FileHeader	access:public	signature:(PersistentBitmap *bitMap)
Debug	lib/debug.cc	/^Debug::Debug(char *flagList)$/;"	f	class:Debug	signature:(char *flagList)
Debug	lib/debug.h	/^    Debug(char *flagList);$/;"	p	class:Debug	access:public	signature:(char *flagList)
Debug	lib/debug.h	/^class Debug {$/;"	c
Debug::Debug	lib/debug.cc	/^Debug::Debug(char *flagList)$/;"	f	class:Debug	signature:(char *flagList)
Debug::Debug	lib/debug.h	/^    Debug(char *flagList);$/;"	p	class:Debug	access:public	signature:(char *flagList)
Debug::IsEnabled	lib/debug.cc	/^Debug::IsEnabled(char flag)$/;"	f	class:Debug	signature:(char flag)
Debug::IsEnabled	lib/debug.h	/^    bool IsEnabled(char flag);$/;"	p	class:Debug	access:public	signature:(char flag)
Debug::enableFlags	lib/debug.h	/^    char *enableFlags;		\/\/ controls which DEBUG messages are printed$/;"	m	class:Debug	access:private
Debugger	machine/machine.cc	/^void Machine::Debugger()$/;"	f	class:Machine	signature:()
Debugger	machine/machine.h	/^    void Debugger();		\/\/ invoke the user program debugger$/;"	p	class:Machine	access:private	signature:()
Decode	machine/mipssim.cc	/^    void Decode();	\/\/ decode the binary representation of the instruction$/;"	p	class:Instruction	file:	access:public	signature:()
Decode	machine/mipssim.cc	/^Instruction::Decode()$/;"	f	class:Instruction	signature:()
Delay	lib/sysdep.cc	/^Delay(int seconds)$/;"	f	signature:(int seconds)
Delay	lib/sysdep.h	/^extern void Delay(int seconds);$/;"	p	signature:(int seconds)
DelayedLoad	machine/machine.h	/^    void DelayedLoad(int nextReg, int nextVal);  	$/;"	p	class:Machine	access:private	signature:(int nextReg, int nextVal)
DelayedLoad	machine/mipssim.cc	/^Machine::DelayedLoad(int nextReg, int nextValue)$/;"	f	class:Machine	signature:(int nextReg, int nextValue)
DeleteBuckets	lib/hash.cc	/^HashTable<Key,T>::DeleteBuckets(List<T> **table, int sz)$/;"	f	class:HashTable	signature:(List<T> **table, int sz)
DeleteBuckets	lib/hash.h	/^    void DeleteBuckets(Bucket *table, int size);$/;"	p	class:HashTable	access:private	signature:(Bucket *table, int size)
Dim	test/matmult.c	12;"	d	file:
Directory	filesys/directory.cc	/^Directory::Directory(int size)$/;"	f	class:Directory	signature:(int size)
Directory	filesys/directory.h	/^    Directory(int size); 		\/\/ Initialize an empty directory$/;"	p	class:Directory	access:public	signature:(int size)
Directory	filesys/directory.h	/^class Directory {$/;"	c
Directory::Add	filesys/directory.cc	/^Directory::Add(char *name, int newSector)$/;"	f	class:Directory	signature:(char *name, int newSector)
Directory::Add	filesys/directory.h	/^    bool Add(char *name, int newSector);  \/\/ Add a file name into the directory$/;"	p	class:Directory	access:public	signature:(char *name, int newSector)
Directory::Directory	filesys/directory.cc	/^Directory::Directory(int size)$/;"	f	class:Directory	signature:(int size)
Directory::Directory	filesys/directory.h	/^    Directory(int size); 		\/\/ Initialize an empty directory$/;"	p	class:Directory	access:public	signature:(int size)
Directory::FetchFrom	filesys/directory.cc	/^Directory::FetchFrom(OpenFile *file)$/;"	f	class:Directory	signature:(OpenFile *file)
Directory::FetchFrom	filesys/directory.h	/^    void FetchFrom(OpenFile *file);  	\/\/ Init directory contents from disk$/;"	p	class:Directory	access:public	signature:(OpenFile *file)
Directory::Find	filesys/directory.cc	/^Directory::Find(char *name)$/;"	f	class:Directory	signature:(char *name)
Directory::Find	filesys/directory.h	/^    int Find(char *name);		\/\/ Find the sector number of the $/;"	p	class:Directory	access:public	signature:(char *name)
Directory::FindIndex	filesys/directory.cc	/^Directory::FindIndex(char *name)$/;"	f	class:Directory	signature:(char *name)
Directory::FindIndex	filesys/directory.h	/^    int FindIndex(char *name);		\/\/ Find the index into the directory $/;"	p	class:Directory	access:private	signature:(char *name)
Directory::List	filesys/directory.cc	/^Directory::List()$/;"	f	class:Directory	signature:()
Directory::List	filesys/directory.h	/^    void List();			\/\/ Print the names of all the files$/;"	p	class:Directory	access:public	signature:()
Directory::Print	filesys/directory.cc	/^Directory::Print()$/;"	f	class:Directory	signature:()
Directory::Print	filesys/directory.h	/^    void Print();			\/\/ Verbose print of the contents$/;"	p	class:Directory	access:public	signature:()
Directory::Remove	filesys/directory.cc	/^Directory::Remove(char *name)$/;"	f	class:Directory	signature:(char *name)
Directory::Remove	filesys/directory.h	/^    bool Remove(char *name);		\/\/ Remove a file from the directory$/;"	p	class:Directory	access:public	signature:(char *name)
Directory::WriteBack	filesys/directory.cc	/^Directory::WriteBack(OpenFile *file)$/;"	f	class:Directory	signature:(OpenFile *file)
Directory::WriteBack	filesys/directory.h	/^    void WriteBack(OpenFile *file);	\/\/ Write modifications to $/;"	p	class:Directory	access:public	signature:(OpenFile *file)
Directory::table	filesys/directory.h	/^    DirectoryEntry *table;		\/\/ Table of pairs: $/;"	m	class:Directory	access:private
Directory::tableSize	filesys/directory.h	/^    int tableSize;			\/\/ Number of directory entries$/;"	m	class:Directory	access:private
Directory::~Directory	filesys/directory.cc	/^Directory::~Directory()$/;"	f	class:Directory	signature:()
Directory::~Directory	filesys/directory.h	/^    ~Directory();			\/\/ De-allocate the directory$/;"	p	class:Directory	access:public	signature:()
DirectoryEntry	filesys/directory.h	/^class DirectoryEntry {$/;"	c
DirectoryEntry::inUse	filesys/directory.h	/^    bool inUse;				\/\/ Is this directory entry in use?$/;"	m	class:DirectoryEntry	access:public
DirectoryEntry::name	filesys/directory.h	/^    char name[FileNameMaxLen + 1];	\/\/ Text name for file, with +1 for $/;"	m	class:DirectoryEntry	access:public
DirectoryEntry::sector	filesys/directory.h	/^    int sector;				\/\/ Location on disk to find the $/;"	m	class:DirectoryEntry	access:public
DirectoryFileSize	filesys/filesys.cc	66;"	d	file:
DirectorySector	filesys/filesys.cc	59;"	d	file:
Disable	machine/timer.h	/^    void Disable() { disable = TRUE; }$/;"	f	class:Timer	access:public	signature:()
Disk	machine/disk.cc	/^Disk::Disk(CallBackObj *toCall)$/;"	f	class:Disk	signature:(CallBackObj *toCall)
Disk	machine/disk.h	/^    Disk(CallBackObj *toCall);          \/\/ Create a simulated disk.  $/;"	p	class:Disk	access:public	signature:(CallBackObj *toCall)
Disk	machine/disk.h	/^class Disk : public CallBackObj {$/;"	c	inherits:CallBackObj
Disk::CallBack	machine/disk.cc	/^Disk::CallBack ()$/;"	f	class:Disk	signature:()
Disk::CallBack	machine/disk.h	/^    void CallBack();			\/\/ Invoked when disk request $/;"	p	class:Disk	access:public	signature:()
Disk::ComputeLatency	machine/disk.cc	/^Disk::ComputeLatency(int newSector, bool writing)$/;"	f	class:Disk	signature:(int newSector, bool writing)
Disk::ComputeLatency	machine/disk.h	/^    int ComputeLatency(int newSector, bool writing);	$/;"	p	class:Disk	access:public	signature:(int newSector, bool writing)
Disk::Disk	machine/disk.cc	/^Disk::Disk(CallBackObj *toCall)$/;"	f	class:Disk	signature:(CallBackObj *toCall)
Disk::Disk	machine/disk.h	/^    Disk(CallBackObj *toCall);          \/\/ Create a simulated disk.  $/;"	p	class:Disk	access:public	signature:(CallBackObj *toCall)
Disk::ModuloDiff	machine/disk.cc	/^Disk::ModuloDiff(int to, int from)$/;"	f	class:Disk	signature:(int to, int from)
Disk::ModuloDiff	machine/disk.h	/^    int ModuloDiff(int to, int from);        \/\/ # sectors between to and from$/;"	p	class:Disk	access:private	signature:(int to, int from)
Disk::ReadRequest	machine/disk.cc	/^Disk::ReadRequest(int sectorNumber, char* data)$/;"	f	class:Disk	signature:(int sectorNumber, char* data)
Disk::ReadRequest	machine/disk.h	/^    void ReadRequest(int sectorNumber, char* data);$/;"	p	class:Disk	access:public	signature:(int sectorNumber, char* data)
Disk::TimeToSeek	machine/disk.cc	/^Disk::TimeToSeek(int newSector, int *rotation) $/;"	f	class:Disk	signature:(int newSector, int *rotation)
Disk::TimeToSeek	machine/disk.h	/^    int TimeToSeek(int newSector, int *rotate); \/\/ time to get to the new track$/;"	p	class:Disk	access:private	signature:(int newSector, int *rotate)
Disk::UpdateLast	machine/disk.cc	/^Disk::UpdateLast(int newSector)$/;"	f	class:Disk	signature:(int newSector)
Disk::UpdateLast	machine/disk.h	/^    void UpdateLast(int newSector);$/;"	p	class:Disk	access:private	signature:(int newSector)
Disk::WriteRequest	machine/disk.cc	/^Disk::WriteRequest(int sectorNumber, char* data)$/;"	f	class:Disk	signature:(int sectorNumber, char* data)
Disk::WriteRequest	machine/disk.h	/^    void WriteRequest(int sectorNumber, char* data);$/;"	p	class:Disk	access:public	signature:(int sectorNumber, char* data)
Disk::active	machine/disk.h	/^    bool active;     			\/\/ Is a disk operation in progress?$/;"	m	class:Disk	access:private
Disk::bufferInit	machine/disk.h	/^    int bufferInit;			\/\/ When the track buffer started $/;"	m	class:Disk	access:private
Disk::callWhenDone	machine/disk.h	/^    CallBackObj *callWhenDone;		\/\/ Invoke when any disk request finishes$/;"	m	class:Disk	access:private
Disk::diskname	machine/disk.h	/^    char diskname[32];			\/\/ name of simulated disk's file$/;"	m	class:Disk	access:private
Disk::fileno	machine/disk.h	/^    int fileno;				\/\/ UNIX file number for simulated disk $/;"	m	class:Disk	access:private
Disk::lastSector	machine/disk.h	/^    int lastSector;			\/\/ The previous disk request $/;"	m	class:Disk	access:private
Disk::~Disk	machine/disk.cc	/^Disk::~Disk()$/;"	f	class:Disk	signature:()
Disk::~Disk	machine/disk.h	/^    ~Disk();				\/\/ Deallocate the disk.$/;"	p	class:Disk	access:public	signature:()
DiskInt	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	e	enum:IntType
DiskSize	machine/disk.cc	/^const int DiskSize = (MagicSize + (NumSectors * SectorSize));$/;"	v
DumpState	machine/interrupt.cc	/^Interrupt::DumpState()$/;"	f	class:Interrupt	signature:()
DumpState	machine/interrupt.h	/^    void DumpState();		\/\/ Print interrupt state$/;"	p	class:Interrupt	access:public	signature:()
DumpState	machine/machine.cc	/^Machine::DumpState()$/;"	f	class:Machine	signature:()
DumpState	machine/machine.h	/^    void DumpState();		\/\/ print the user CPU and memory state $/;"	p	class:Machine	access:private	signature:()
E2BIG	userprog/errno.h	32;"	d
EACCES	userprog/errno.h	38;"	d
EAGAIN	userprog/errno.h	36;"	d
EBADE	userprog/errno.h	77;"	d
EBADF	userprog/errno.h	34;"	d
EBADR	userprog/errno.h	78;"	d
EBADRQC	userprog/errno.h	81;"	d
EBADSLT	userprog/errno.h	82;"	d
EBUSY	userprog/errno.h	41;"	d
ECHILD	userprog/errno.h	35;"	d
ECHRNG	userprog/errno.h	69;"	d
EDEADLK	userprog/errno.h	60;"	d
EDOM	userprog/errno.h	58;"	d
EEXIST	userprog/errno.h	42;"	d
EFAULT	userprog/errno.h	39;"	d
EFBIG	userprog/errno.h	52;"	d
EIDRM	userprog/errno.h	68;"	d
EINTR	userprog/errno.h	29;"	d
EINVAL	userprog/errno.h	47;"	d
EIO	userprog/errno.h	30;"	d
EISDIR	userprog/errno.h	46;"	d
EL2HLT	userprog/errno.h	76;"	d
EL2NSYNC	userprog/errno.h	70;"	d
EL3HLT	userprog/errno.h	71;"	d
EL3RST	userprog/errno.h	72;"	d
ELNRNG	userprog/errno.h	73;"	d
ELOOP	userprog/errno.h	65;"	d
EMFILE	userprog/errno.h	49;"	d
EMLINK	userprog/errno.h	56;"	d
ENAMETOOLONG	userprog/errno.h	61;"	d
ENFILE	userprog/errno.h	48;"	d
ENOANO	userprog/errno.h	80;"	d
ENOCSI	userprog/errno.h	75;"	d
ENODEV	userprog/errno.h	44;"	d
ENOENT	userprog/errno.h	27;"	d
ENOEXEC	userprog/errno.h	33;"	d
ENOLCK	userprog/errno.h	62;"	d
ENOMEM	userprog/errno.h	37;"	d
ENOMSG	userprog/errno.h	67;"	d
ENOSPC	userprog/errno.h	53;"	d
ENOSYS	userprog/errno.h	63;"	d
ENOTBLK	userprog/errno.h	40;"	d
ENOTDIR	userprog/errno.h	45;"	d
ENOTEMPTY	userprog/errno.h	64;"	d
ENOTTY	userprog/errno.h	50;"	d
ENXIO	userprog/errno.h	31;"	d
EPERM	userprog/errno.h	26;"	d
EPIPE	userprog/errno.h	57;"	d
ERANGE	userprog/errno.h	59;"	d
EROFS	userprog/errno.h	55;"	d
ERRNO_H	userprog/errno.h	22;"	d
ESPIPE	userprog/errno.h	54;"	d
ESRCH	userprog/errno.h	28;"	d
ETXTBSY	userprog/errno.h	51;"	d
EUNATCH	userprog/errno.h	74;"	d
EWOULDBLOCK	userprog/errno.h	66;"	d
EXDEV	userprog/errno.h	43;"	d
EXFULL	userprog/errno.h	79;"	d
EXTRA	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
Enable	machine/interrupt.h	/^    void Enable() { (void) SetLevel(IntOn); }$/;"	f	class:Interrupt	access:public	signature:()
ExceptionHandler	machine/machine.h	/^extern void ExceptionHandler(ExceptionType which);$/;"	p	signature:(ExceptionType which)
ExceptionHandler	userprog/exception.cc	/^void ExceptionHandler(ExceptionType which)$/;"	f	signature:(ExceptionType which)
ExceptionType	machine/machine.h	/^enum ExceptionType { NoException,           \/\/ Everything ok!$/;"	g
Exec	test/start.S	/^Exec:$/;"	l
Exec	userprog/syscall.h	/^SpaceId Exec(char* exec_name);$/;"	p	signature:(char* exec_name)
ExecV	test/start.S	/^ExecV:$/;"	l
ExecV	userprog/syscall.h	/^SpaceId ExecV(int argc, char* argv[]);$/;"	p	signature:(int argc, char* argv[])
Execute	userprog/addrspace.cc	/^AddrSpace::Execute() $/;"	f	class:AddrSpace	signature:()
Execute	userprog/addrspace.h	/^    void Execute();             	\/\/ Run a program$/;"	p	class:AddrSpace	access:public	signature:()
Exit	lib/sysdep.cc	/^Exit(int exitCode)$/;"	f	signature:(int exitCode)
Exit	lib/sysdep.h	/^extern void Exit(int exitCode);$/;"	p	signature:(int exitCode)
Exit	test/sort.c	18;"	d	file:
Exit	test/start.S	/^Exit:$/;"	l
Exit	userprog/syscall.h	/^void Exit(int status);	$/;"	p	signature:(int status)
FALSE	lib/utility.h	17;"	d
FILEHDR_H	filesys/filehdr.h	15;"	d
FILESYS_C	build.cygwin/Makefile	/^FILESYS_C =..\/filesys\/directory.cc\\$/;"	m
FILESYS_C	build.linux/Makefile	/^FILESYS_C =..\/filesys\/directory.cc\\$/;"	m
FILESYS_C	build.macosx/Makefile	/^FILESYS_C =..\/filesys\/directory.cc\\$/;"	m
FILESYS_H	build.cygwin/Makefile	/^FILESYS_H =..\/filesys\/directory.h \\$/;"	m
FILESYS_H	build.linux/Makefile	/^FILESYS_H =..\/filesys\/directory.h \\$/;"	m
FILESYS_H	build.macosx/Makefile	/^FILESYS_H =..\/filesys\/directory.h \\$/;"	m
FILESYS_O	build.cygwin/Makefile	/^FILESYS_O =directory.o filehdr.o filesys.o pbitmap.o openfile.o synchdisk.o$/;"	m
FILESYS_O	build.linux/Makefile	/^FILESYS_O =directory.o filehdr.o filesys.o pbitmap.o openfile.o synchdisk.o$/;"	m
FILESYS_O	build.macosx/Makefile	/^FILESYS_O =directory.o filehdr.o filesys.o pbitmap.o openfile.o synchdisk.o$/;"	m
FP	threads/switch.h	38;"	d
FP	threads/switch.h	78;"	d
FP13	threads/switch.h	185;"	d
FP15	threads/switch.h	186;"	d
FP16	threads/switch.h	187;"	d
FP17	threads/switch.h	188;"	d
FP18	threads/switch.h	189;"	d
FP19	threads/switch.h	190;"	d
FP20	threads/switch.h	191;"	d
FP21	threads/switch.h	192;"	d
FP22	threads/switch.h	193;"	d
FP23	threads/switch.h	194;"	d
FP24	threads/switch.h	195;"	d
FP25	threads/switch.h	196;"	d
FP26	threads/switch.h	197;"	d
FP27	threads/switch.h	198;"	d
FP28	threads/switch.h	199;"	d
FP29	threads/switch.h	200;"	d
FP30	threads/switch.h	201;"	d
FP31	threads/switch.h	202;"	d
FPState	threads/switch.h	146;"	d
FPState	threads/switch.h	260;"	d
FPState	threads/switch.h	57;"	d
FS_H	filesys/filesys.h	34;"	d
FetchFrom	filesys/directory.cc	/^Directory::FetchFrom(OpenFile *file)$/;"	f	class:Directory	signature:(OpenFile *file)
FetchFrom	filesys/directory.h	/^    void FetchFrom(OpenFile *file);  	\/\/ Init directory contents from disk$/;"	p	class:Directory	access:public	signature:(OpenFile *file)
FetchFrom	filesys/filehdr.cc	/^FileHeader::FetchFrom(int sector)$/;"	f	class:FileHeader	signature:(int sector)
FetchFrom	filesys/filehdr.h	/^    void FetchFrom(int sectorNumber); 	\/\/ Initialize file header from disk$/;"	p	class:FileHeader	access:public	signature:(int sectorNumber)
FetchFrom	filesys/pbitmap.cc	/^PersistentBitmap::FetchFrom(OpenFile *file) $/;"	f	class:PersistentBitmap	signature:(OpenFile *file)
FetchFrom	filesys/pbitmap.h	/^    void FetchFrom(OpenFile *file);     \/\/ read bitmap from the disk$/;"	p	class:PersistentBitmap	access:public	signature:(OpenFile *file)
FileHeader	filesys/filehdr.h	/^class FileHeader {$/;"	c
FileHeader::Allocate	filesys/filehdr.cc	/^FileHeader::Allocate(PersistentBitmap *freeMap, int fileSize)$/;"	f	class:FileHeader	signature:(PersistentBitmap *freeMap, int fileSize)
FileHeader::Allocate	filesys/filehdr.h	/^    bool Allocate(PersistentBitmap *bitMap, int fileSize);\/\/ Initialize a file header, $/;"	p	class:FileHeader	access:public	signature:(PersistentBitmap *bitMap, int fileSize)
FileHeader::ByteToSector	filesys/filehdr.cc	/^FileHeader::ByteToSector(int offset)$/;"	f	class:FileHeader	signature:(int offset)
FileHeader::ByteToSector	filesys/filehdr.h	/^    int ByteToSector(int offset);	\/\/ Convert a byte offset into the file$/;"	p	class:FileHeader	access:public	signature:(int offset)
FileHeader::Deallocate	filesys/filehdr.cc	/^FileHeader::Deallocate(PersistentBitmap *freeMap)$/;"	f	class:FileHeader	signature:(PersistentBitmap *freeMap)
FileHeader::Deallocate	filesys/filehdr.h	/^    void Deallocate(PersistentBitmap *bitMap);  \/\/ De-allocate this file's $/;"	p	class:FileHeader	access:public	signature:(PersistentBitmap *bitMap)
FileHeader::FetchFrom	filesys/filehdr.cc	/^FileHeader::FetchFrom(int sector)$/;"	f	class:FileHeader	signature:(int sector)
FileHeader::FetchFrom	filesys/filehdr.h	/^    void FetchFrom(int sectorNumber); 	\/\/ Initialize file header from disk$/;"	p	class:FileHeader	access:public	signature:(int sectorNumber)
FileHeader::FileLength	filesys/filehdr.cc	/^FileHeader::FileLength()$/;"	f	class:FileHeader	signature:()
FileHeader::FileLength	filesys/filehdr.h	/^    int FileLength();			\/\/ Return the length of the file $/;"	p	class:FileHeader	access:public	signature:()
FileHeader::Print	filesys/filehdr.cc	/^FileHeader::Print()$/;"	f	class:FileHeader	signature:()
FileHeader::Print	filesys/filehdr.h	/^    void Print();			\/\/ Print the contents of the file.$/;"	p	class:FileHeader	access:public	signature:()
FileHeader::WriteBack	filesys/filehdr.cc	/^FileHeader::WriteBack(int sector)$/;"	f	class:FileHeader	signature:(int sector)
FileHeader::WriteBack	filesys/filehdr.h	/^    void WriteBack(int sectorNumber); 	\/\/ Write modifications to file header$/;"	p	class:FileHeader	access:public	signature:(int sectorNumber)
FileHeader::dataSectors	filesys/filehdr.h	/^    int dataSectors[NumDirect];		\/\/ Disk sector numbers for each data $/;"	m	class:FileHeader	access:private
FileHeader::numBytes	filesys/filehdr.h	/^    int numBytes;			\/\/ Number of bytes in the file$/;"	m	class:FileHeader	access:private
FileHeader::numSectors	filesys/filehdr.h	/^    int numSectors;			\/\/ Number of data sectors in the file$/;"	m	class:FileHeader	access:private
FileLength	filesys/filehdr.cc	/^FileHeader::FileLength()$/;"	f	class:FileHeader	signature:()
FileLength	filesys/filehdr.h	/^    int FileLength();			\/\/ Return the length of the file $/;"	p	class:FileHeader	access:public	signature:()
FileNameMaxLen	filesys/directory.h	22;"	d
FileSystem	filesys/filesys.cc	/^FileSystem::FileSystem(bool format)$/;"	f	class:FileSystem	signature:(bool format)
FileSystem	filesys/filesys.h	/^    FileSystem() {}$/;"	f	class:FileSystem	access:public	signature:()
FileSystem	filesys/filesys.h	/^    FileSystem(bool format);		\/\/ Initialize the file system.$/;"	p	class:FileSystem	access:public	signature:(bool format)
FileSystem	filesys/filesys.h	/^class FileSystem {$/;"	c
FileSystem::Create	filesys/filesys.cc	/^FileSystem::Create(char *name, int initialSize)$/;"	f	class:FileSystem	signature:(char *name, int initialSize)
FileSystem::Create	filesys/filesys.h	/^    bool Create(char *name) {$/;"	f	class:FileSystem	access:public	signature:(char *name)
FileSystem::Create	filesys/filesys.h	/^    bool Create(char *name, int initialSize);  	$/;"	p	class:FileSystem	access:public	signature:(char *name, int initialSize)
FileSystem::FileSystem	filesys/filesys.cc	/^FileSystem::FileSystem(bool format)$/;"	f	class:FileSystem	signature:(bool format)
FileSystem::FileSystem	filesys/filesys.h	/^    FileSystem() {}$/;"	f	class:FileSystem	access:public	signature:()
FileSystem::FileSystem	filesys/filesys.h	/^    FileSystem(bool format);		\/\/ Initialize the file system.$/;"	p	class:FileSystem	access:public	signature:(bool format)
FileSystem::List	filesys/filesys.cc	/^FileSystem::List()$/;"	f	class:FileSystem	signature:()
FileSystem::List	filesys/filesys.h	/^    void List();			\/\/ List all the files in the file system$/;"	p	class:FileSystem	access:public	signature:()
FileSystem::Open	filesys/filesys.cc	/^FileSystem::Open(char *name)$/;"	f	class:FileSystem	signature:(char *name)
FileSystem::Open	filesys/filesys.h	/^    OpenFile* Open(char *name) {$/;"	f	class:FileSystem	access:public	signature:(char *name)
FileSystem::Open	filesys/filesys.h	/^    OpenFile* Open(char *name); 	\/\/ Open a file (UNIX open)$/;"	p	class:FileSystem	access:public	signature:(char *name)
FileSystem::Print	filesys/filesys.cc	/^FileSystem::Print()$/;"	f	class:FileSystem	signature:()
FileSystem::Print	filesys/filesys.h	/^    void Print();			\/\/ List all the files and their contents$/;"	p	class:FileSystem	access:public	signature:()
FileSystem::Remove	filesys/filesys.cc	/^FileSystem::Remove(char *name)$/;"	f	class:FileSystem	signature:(char *name)
FileSystem::Remove	filesys/filesys.h	/^    bool Remove(char *name) { return Unlink(name) == 0; }$/;"	f	class:FileSystem	access:public	signature:(char *name)
FileSystem::Remove	filesys/filesys.h	/^    bool Remove(char *name);  		\/\/ Delete a file (UNIX unlink)$/;"	p	class:FileSystem	access:public	signature:(char *name)
FileSystem::directoryFile	filesys/filesys.h	/^   OpenFile* directoryFile;		\/\/ "Root" directory -- list of $/;"	m	class:FileSystem	access:private
FileSystem::freeMapFile	filesys/filesys.h	/^   OpenFile* freeMapFile;		\/\/ Bit map of free disk blocks,$/;"	m	class:FileSystem	access:private
Find	filesys/directory.cc	/^Directory::Find(char *name)$/;"	f	class:Directory	signature:(char *name)
Find	filesys/directory.h	/^    int Find(char *name);		\/\/ Find the sector number of the $/;"	p	class:Directory	access:public	signature:(char *name)
Find	lib/hash.cc	/^HashTable<Key,T>::Find(Key key, T *itemPtr) const$/;"	f	class:HashTable	signature:(Key key, T *itemPtr) const
Find	lib/hash.h	/^    bool Find(Key key, T *itemPtr) const; $/;"	p	class:HashTable	access:public	signature:(Key key, T *itemPtr) const
FindAndSet	lib/bitmap.cc	/^Bitmap::FindAndSet() $/;"	f	class:Bitmap	signature:()
FindAndSet	lib/bitmap.h	/^    int FindAndSet();         \/\/ Return the # of a clear bit, and as a side$/;"	p	class:Bitmap	access:public	signature:()
FindInBucket	lib/hash.cc	/^HashTable<Key,T>::FindInBucket(int bucket, $/;"	f	class:HashTable	signature:(int bucket, Key key, T *itemPtr) const
FindInBucket	lib/hash.h	/^    bool FindInBucket(int bucket, Key key, T *itemPtr) const; $/;"	p	class:HashTable	access:private	signature:(int bucket, Key key, T *itemPtr) const
FindIndex	filesys/directory.cc	/^Directory::FindIndex(char *name)$/;"	f	class:Directory	signature:(char *name)
FindIndex	filesys/directory.h	/^    int FindIndex(char *name);		\/\/ Find the index into the directory $/;"	p	class:Directory	access:private	signature:(char *name)
FindNextFullBucket	lib/hash.cc	/^HashTable<Key,T>::FindNextFullBucket(int bucket) const$/;"	f	class:HashTable	signature:(int bucket) const
FindNextFullBucket	lib/hash.h	/^    int FindNextFullBucket(int start) const;$/;"	p	class:HashTable	access:private	signature:(int start) const
FindNextToRun	threads/scheduler.cc	/^Scheduler::FindNextToRun ()$/;"	f	class:Scheduler	signature:()
FindNextToRun	threads/scheduler.h	/^    Thread* FindNextToRun();	\/\/ Dequeue first thread on the ready $/;"	p	class:Scheduler	access:public	signature:()
Finish	threads/thread.cc	/^Thread::Finish ()$/;"	f	class:Thread	signature:()
Finish	threads/thread.h	/^    void Finish();  		\/\/ The thread is done executing$/;"	p	class:Thread	access:public	signature:()
Fork	threads/thread.cc	/^Thread::Fork(VoidFunctionPtr func, void *arg)$/;"	f	class:Thread	signature:(VoidFunctionPtr func, void *arg)
Fork	threads/thread.h	/^    void Fork(VoidFunctionPtr func, void *arg); $/;"	p	class:Thread	access:public	signature:(VoidFunctionPtr func, void *arg)
FreeMapFileSize	filesys/filesys.cc	64;"	d	file:
FreeMapSector	filesys/filesys.cc	58;"	d	file:
Front	lib/list.h	/^    T Front() { return first->item; }$/;"	f	class:List	access:public	signature:()
GP	threads/switch.h	242;"	d
GP13	threads/switch.h	166;"	d
GP14	threads/switch.h	167;"	d
GP15	threads/switch.h	168;"	d
GP16	threads/switch.h	169;"	d
GP17	threads/switch.h	170;"	d
GP18	threads/switch.h	171;"	d
GP19	threads/switch.h	172;"	d
GP20	threads/switch.h	173;"	d
GP21	threads/switch.h	174;"	d
GP22	threads/switch.h	175;"	d
GP23	threads/switch.h	176;"	d
GP24	threads/switch.h	177;"	d
GP25	threads/switch.h	178;"	d
GP26	threads/switch.h	179;"	d
GP27	threads/switch.h	180;"	d
GP28	threads/switch.h	181;"	d
GP29	threads/switch.h	182;"	d
GP30	threads/switch.h	183;"	d
GP31	threads/switch.h	184;"	d
Get	network/post.cc	/^MailBox::Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data) $/;"	f	class:MailBox	signature:(PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
Get	network/post.h	/^    void Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data); $/;"	p	class:MailBox	access:public	signature:(PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
GetChar	machine/console.cc	/^ConsoleInput::GetChar()$/;"	f	class:ConsoleInput	signature:()
GetChar	machine/console.h	/^    char GetChar();	   	\/\/ Poll the console input.  If a char is $/;"	p	class:ConsoleInput	access:public	signature:()
GetChar	userprog/synchconsole.cc	/^SynchConsoleInput::GetChar()$/;"	f	class:SynchConsoleInput	signature:()
GetChar	userprog/synchconsole.h	/^    char GetChar();		\/\/ Read a character, waiting if necessary$/;"	p	class:SynchConsoleInput	access:public	signature:()
HASH_H	lib/hash.h	30;"	d
HFILES	build.cygwin/Makefile	/^HFILES = $(LIB_H) $(MACHINE_H) $(THREAD_H) $(USERPROG_H) $(FILESYS_H) $(NETWORK_H)$/;"	m
HFILES	build.linux/Makefile	/^HFILES = $(LIB_H) $(MACHINE_H) $(THREAD_H) $(USERPROG_H) $(FILESYS_H) $(NETWORK_H)$/;"	m
HFILES	build.macosx/Makefile	/^HFILES = $(LIB_H) $(MACHINE_H) $(THREAD_H) $(USERPROG_H) $(FILESYS_H) $(NETWORK_H)$/;"	m
Halt	machine/interrupt.cc	/^Interrupt::Halt()$/;"	f	class:Interrupt	signature:()
Halt	machine/interrupt.h	/^    void Halt(); 		\/\/ quit and print out stats$/;"	p	class:Interrupt	access:public	signature:()
Halt	test/start.S	/^Halt:$/;"	l
Halt	userprog/syscall.h	/^void Halt();		$/;"	p	signature:()
HashInt	lib/libtest.cc	/^HashInt(int key) {$/;"	f	file:	signature:(int key)
HashIterator	lib/hash.cc	/^HashIterator<Key,T>::HashIterator(HashTable<Key,T> *tbl) $/;"	f	class:HashIterator	signature:(HashTable<Key,T> *tbl)
HashIterator	lib/hash.h	/^    HashIterator(HashTable<Key,T> *table); \/\/ initialize an iterator$/;"	p	class:HashIterator	access:public	signature:(HashTable<Key,T> *table)
HashIterator	lib/hash.h	/^class HashIterator {$/;"	c
HashIterator::HashIterator	lib/hash.cc	/^HashIterator<Key,T>::HashIterator(HashTable<Key,T> *tbl) $/;"	f	class:HashIterator	signature:(HashTable<Key,T> *tbl)
HashIterator::HashIterator	lib/hash.h	/^    HashIterator(HashTable<Key,T> *table); \/\/ initialize an iterator$/;"	p	class:HashIterator	access:public	signature:(HashTable<Key,T> *table)
HashIterator::IsDone	lib/hash.h	/^    bool IsDone() { return (bucket == table->numBuckets); };$/;"	f	class:HashIterator	access:public	signature:()
HashIterator::Item	lib/hash.h	/^    T Item() { ASSERT(!IsDone()); return bucketIter->Item(); }; $/;"	f	class:HashIterator	access:public	signature:()
HashIterator::Next	lib/hash.cc	/^HashIterator<Key,T>::Next() $/;"	f	class:HashIterator	signature:()
HashIterator::Next	lib/hash.h	/^    void Next(); 		\/\/ update iterator to point to next$/;"	p	class:HashIterator	access:public	signature:()
HashIterator::bucket	lib/hash.h	/^    int bucket;			\/\/ current bucket we are in$/;"	m	class:HashIterator	access:private
HashIterator::bucketIter	lib/hash.h	/^    ListIterator<T> *bucketIter; \/\/ where we are in the bucket$/;"	m	class:HashIterator	access:private
HashIterator::table	lib/hash.h	/^    HashTable<Key,T> *table;	\/\/ the hash table we're stepping through$/;"	m	class:HashIterator	access:private
HashIterator::~HashIterator	lib/hash.h	/^    ~HashIterator() { if (bucketIter != NULL) delete bucketIter;}; $/;"	f	class:HashIterator	access:public	signature:()
HashKey	lib/libtest.cc	/^HashKey(char *str) {$/;"	f	file:	signature:(char *str)
HashTable	lib/hash.cc	/^HashTable<Key,T>::HashTable(Key (*get)(T x), unsigned (*hFunc)(Key x))$/;"	f	class:HashTable	signature:(Key (get)T x), unsigned (*hFunc)(Key x))
HashTable	lib/hash.h	/^    HashTable(Key (*get)(T x), unsigned (*hFunc)(Key x));	$/;"	p	class:HashTable	access:public	signature:(Key (get)T x), unsigned (*hFunc)(Key x))
HashTable	lib/hash.h	/^class HashTable {$/;"	c
HashTable::Apply	lib/hash.cc	/^HashTable<Key,T>::Apply(void (*func)(T)) const$/;"	f	class:HashTable	signature:(void (*func)(T)) const
HashTable::Apply	lib/hash.h	/^    void Apply(void (*f)(T)) const;$/;"	p	class:HashTable	access:public	signature:(void (*f)(T)) const
HashTable::Bucket	lib/hash.h	/^typedef List<T> *Bucket;$/;"	t	class:HashTable	access:private
HashTable::DeleteBuckets	lib/hash.cc	/^HashTable<Key,T>::DeleteBuckets(List<T> **table, int sz)$/;"	f	class:HashTable	signature:(List<T> **table, int sz)
HashTable::DeleteBuckets	lib/hash.h	/^    void DeleteBuckets(Bucket *table, int size);$/;"	p	class:HashTable	access:private	signature:(Bucket *table, int size)
HashTable::Find	lib/hash.cc	/^HashTable<Key,T>::Find(Key key, T *itemPtr) const$/;"	f	class:HashTable	signature:(Key key, T *itemPtr) const
HashTable::Find	lib/hash.h	/^    bool Find(Key key, T *itemPtr) const; $/;"	p	class:HashTable	access:public	signature:(Key key, T *itemPtr) const
HashTable::FindInBucket	lib/hash.cc	/^HashTable<Key,T>::FindInBucket(int bucket, $/;"	f	class:HashTable	signature:(int bucket, Key key, T *itemPtr) const
HashTable::FindInBucket	lib/hash.h	/^    bool FindInBucket(int bucket, Key key, T *itemPtr) const; $/;"	p	class:HashTable	access:private	signature:(int bucket, Key key, T *itemPtr) const
HashTable::FindNextFullBucket	lib/hash.cc	/^HashTable<Key,T>::FindNextFullBucket(int bucket) const$/;"	f	class:HashTable	signature:(int bucket) const
HashTable::FindNextFullBucket	lib/hash.h	/^    int FindNextFullBucket(int start) const;$/;"	p	class:HashTable	access:private	signature:(int start) const
HashTable::HashTable	lib/hash.cc	/^HashTable<Key,T>::HashTable(Key (*get)(T x), unsigned (*hFunc)(Key x))$/;"	f	class:HashTable	signature:(Key (get)T x), unsigned (*hFunc)(Key x))
HashTable::HashTable	lib/hash.h	/^    HashTable(Key (*get)(T x), unsigned (*hFunc)(Key x));	$/;"	p	class:HashTable	access:public	signature:(Key (get)T x), unsigned (*hFunc)(Key x))
HashTable::HashValue	lib/hash.cc	/^HashTable<Key, T>::HashValue(Key key) const $/;"	f	class:HashTable	signature:(Key key) const
HashTable::HashValue	lib/hash.h	/^    int HashValue(Key key) const;$/;"	p	class:HashTable	access:private	signature:(Key key) const
HashTable::InitBuckets	lib/hash.cc	/^HashTable<Key,T>::InitBuckets(int sz)$/;"	f	class:HashTable	signature:(int sz)
HashTable::InitBuckets	lib/hash.h	/^    void InitBuckets(int size);\/\/ initialize bucket array$/;"	p	class:HashTable	access:private	signature:(int size)
HashTable::Insert	lib/hash.cc	/^HashTable<Key,T>::Insert(T item)$/;"	f	class:HashTable	signature:(T item)
HashTable::Insert	lib/hash.h	/^    void Insert(T item);	\/\/ Put item into hash table$/;"	p	class:HashTable	access:public	signature:(T item)
HashTable::IsEmpty	lib/hash.h	/^    bool IsEmpty() { return numItems == 0; }	$/;"	f	class:HashTable	access:public	signature:()
HashTable::IsInTable	lib/hash.h	/^    bool IsInTable(Key key) { T dummy; return Find(key, &dummy); } 	$/;"	f	class:HashTable	access:public	signature:(Key key)
HashTable::ReHash	lib/hash.cc	/^HashTable<Key,T>::ReHash()$/;"	f	class:HashTable	signature:()
HashTable::ReHash	lib/hash.h	/^    void ReHash();		\/\/ expand the hash table$/;"	p	class:HashTable	access:private	signature:()
HashTable::Remove	lib/hash.cc	/^HashTable<Key,T>::Remove(Key key)$/;"	f	class:HashTable	signature:(Key key)
HashTable::Remove	lib/hash.h	/^    T Remove(Key key);		\/\/ Remove item from hash table.$/;"	p	class:HashTable	access:public	signature:(Key key)
HashTable::SanityCheck	lib/hash.cc	/^HashTable<Key,T>::SanityCheck() const$/;"	f	class:HashTable	signature:() const
HashTable::SanityCheck	lib/hash.h	/^    void SanityCheck() const;\/\/ is this still a legal hash table?$/;"	p	class:HashTable	access:public	signature:() const
HashTable::SelfTest	lib/hash.cc	/^HashTable<Key,T>::SelfTest(T *p, int numEntries)$/;"	f	class:HashTable	signature:(T *p, int numEntries)
HashTable::SelfTest	lib/hash.h	/^    void SelfTest(T *p, int numItems);	$/;"	p	class:HashTable	access:public	signature:(T *p, int numItems)
HashTable::buckets	lib/hash.h	/^    Bucket *buckets;		\/\/ the array of hash buckets$/;"	m	class:HashTable	access:private
HashTable::getKey	lib/hash.h	/^    Key (*getKey)(T x);		\/\/ get Key from value$/;"	m	class:HashTable	access:private
HashTable::hash	lib/hash.h	/^    unsigned (*hash)(Key x);	\/\/ the hash function$/;"	m	class:HashTable	access:private
HashTable::numBuckets	lib/hash.h	/^    int numBuckets;		\/\/ the number of buckets$/;"	m	class:HashTable	access:private
HashTable::numItems	lib/hash.h	/^    int numItems;		\/\/ the number of items in the table$/;"	m	class:HashTable	access:private
HashTable::~HashTable	lib/hash.cc	/^HashTable<Key,T>::~HashTable()$/;"	f	class:HashTable	signature:()
HashTable::~HashTable	lib/hash.h	/^    ~HashTable();		\/\/ deallocate a hash table$/;"	p	class:HashTable	access:public	signature:()
HashValue	lib/hash.cc	/^HashTable<Key, T>::HashValue(Key key) const $/;"	f	class:HashTable	signature:(Key key) const
HashValue	lib/hash.h	/^    int HashValue(Key key) const;$/;"	p	class:HashTable	access:private	signature:(Key key) const
HiReg	machine/machine.h	67;"	d
I0	threads/switch.h	68;"	d
I1	threads/switch.h	69;"	d
I2	threads/switch.h	70;"	d
I3	threads/switch.h	71;"	d
I4	threads/switch.h	72;"	d
I5	threads/switch.h	73;"	d
I6	threads/switch.h	74;"	d
I7	threads/switch.h	75;"	d
IFMT	machine/mipssim.h	108;"	d
INCDIR	test/Makefile	/^INCDIR =-I..\/userprog -I..\/lib$/;"	m
INCPATH	build.cygwin/Makefile	/^INCPATH = -I..\/network -I..\/filesys -I..\/userprog -I..\/threads -I..\/machine -I..\/lib$/;"	m
INCPATH	build.linux/Makefile	/^INCPATH = -iquote..\/network -iquote..\/filesys -iquote..\/userprog -iquote..\/threads -iquote..\/machine -iquote..\/lib -iquote-$/;"	m
INCPATH	build.macosx/Makefile	/^INCPATH = -I..\/network -I..\/filesys -I..\/userprog -I..\/threads -I..\/machine -I..\/lib$/;"	m
INTERRUPT_H	machine/interrupt.h	34;"	d
IN_ASM	test/start.S	/^#define IN_ASM$/;"	d
Idle	machine/interrupt.cc	/^Interrupt::Idle()$/;"	f	class:Interrupt	signature:()
Idle	machine/interrupt.h	/^    void Idle(); 		\/\/ The ready queue is empty, roll $/;"	p	class:Interrupt	access:public	signature:()
IdleMode	machine/interrupt.h	/^enum MachineStatus {IdleMode, SystemMode, UserMode};$/;"	e	enum:MachineStatus
IllegalInstrException	machine/machine.h	/^		     IllegalInstrException, \/\/ Unimplemented or reserved instr.$/;"	e	enum:ExceptionType
IncreaseSizeBy	lib/hash.cc	/^const int IncreaseSizeBy = 4;	\/\/ how much do we grow table when needed?$/;"	v
IndexToAddr	machine/mipssim.h	94;"	d
InitBuckets	lib/hash.cc	/^HashTable<Key,T>::InitBuckets(int sz)$/;"	f	class:HashTable	signature:(int sz)
InitBuckets	lib/hash.h	/^    void InitBuckets(int size);\/\/ initialize bucket array$/;"	p	class:HashTable	access:private	signature:(int size)
InitRegisters	userprog/addrspace.cc	/^AddrSpace::InitRegisters()$/;"	f	class:AddrSpace	signature:()
InitRegisters	userprog/addrspace.h	/^    void InitRegisters();		\/\/ Initialize user-level CPU registers,$/;"	p	class:AddrSpace	access:private	signature:()
InitSocketName	lib/sysdep.cc	/^InitSocketName(struct sockaddr_un *uname, char *name)$/;"	f	file:	signature:(struct sockaddr_un *uname, char *name)
InitialArg	threads/switch.h	119;"	d
InitialArg	threads/switch.h	153;"	d
InitialArg	threads/switch.h	219;"	d
InitialArg	threads/switch.h	255;"	d
InitialArg	threads/switch.h	52;"	d
InitialArg	threads/switch.h	83;"	d
InitialArgState	threads/switch.h	125;"	d
InitialArgState	threads/switch.h	148;"	d
InitialArgState	threads/switch.h	211;"	d
InitialArgState	threads/switch.h	262;"	d
InitialArgState	threads/switch.h	59;"	d
InitialArgState	threads/switch.h	89;"	d
InitialBuckets	lib/hash.cc	/^const int InitialBuckets = 4;	\/\/ how big a hash table do we start with$/;"	v
InitialLR	threads/switch.h	218;"	d
InitialPC	threads/switch.h	118;"	d
InitialPC	threads/switch.h	152;"	d
InitialPC	threads/switch.h	254;"	d
InitialPC	threads/switch.h	51;"	d
InitialPC	threads/switch.h	82;"	d
InitialPCState	threads/switch.h	124;"	d
InitialPCState	threads/switch.h	147;"	d
InitialPCState	threads/switch.h	210;"	d
InitialPCState	threads/switch.h	261;"	d
InitialPCState	threads/switch.h	58;"	d
InitialPCState	threads/switch.h	88;"	d
Initialize	threads/kernel.cc	/^Kernel::Initialize()$/;"	f	class:Kernel	signature:()
Initialize	threads/kernel.h	/^    void Initialize(); 		\/\/ initialize the kernel -- separated$/;"	p	class:Kernel	access:public	signature:()
Insert	lib/hash.cc	/^HashTable<Key,T>::Insert(T item)$/;"	f	class:HashTable	signature:(T item)
Insert	lib/hash.h	/^    void Insert(T item);	\/\/ Put item into hash table$/;"	p	class:HashTable	access:public	signature:(T item)
Insert	lib/list.cc	/^SortedList<T>::Insert(T item)$/;"	f	class:SortedList	signature:(T item)
Insert	lib/list.h	/^    void Insert(T item); 	\/\/ insert an item onto the list in sorted order$/;"	p	class:SortedList	access:public	signature:(T item)
Instruction	machine/mipssim.cc	/^class Instruction {$/;"	c	file:
Instruction::Decode	machine/mipssim.cc	/^    void Decode();	\/\/ decode the binary representation of the instruction$/;"	p	class:Instruction	file:	access:public	signature:()
Instruction::Decode	machine/mipssim.cc	/^Instruction::Decode()$/;"	f	class:Instruction	signature:()
Instruction::extra	machine/mipssim.cc	/^    int extra;       \/\/ Immediate or target or shamt field or offset.$/;"	m	class:Instruction	file:	access:public
Instruction::opCode	machine/mipssim.cc	/^    char opCode;     \/\/ Type of instruction.  This is NOT the same as the$/;"	m	class:Instruction	file:	access:public
Instruction::rd	machine/mipssim.cc	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	file:	access:public
Instruction::rs	machine/mipssim.cc	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	file:	access:public
Instruction::rt	machine/mipssim.cc	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	file:	access:public
Instruction::value	machine/mipssim.cc	/^    unsigned int value; \/\/ binary representation of the instruction$/;"	m	class:Instruction	file:	access:public
IntCompare	lib/libtest.cc	/^IntCompare(int x, int y) {$/;"	f	file:	signature:(int x, int y)
IntOff	machine/interrupt.h	/^enum IntStatus { IntOff, IntOn };$/;"	e	enum:IntStatus
IntOn	machine/interrupt.h	/^enum IntStatus { IntOff, IntOn };$/;"	e	enum:IntStatus
IntStatus	machine/interrupt.h	/^enum IntStatus { IntOff, IntOn };$/;"	g
IntType	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	g
Interrupt	machine/interrupt.cc	/^Interrupt::Interrupt()$/;"	f	class:Interrupt	signature:()
Interrupt	machine/interrupt.h	/^    Interrupt();		\/\/ initialize the interrupt simulation$/;"	p	class:Interrupt	access:public	signature:()
Interrupt	machine/interrupt.h	/^class Interrupt {$/;"	c
Interrupt::ChangeLevel	machine/interrupt.cc	/^Interrupt::ChangeLevel(IntStatus old, IntStatus now)$/;"	f	class:Interrupt	signature:(IntStatus old, IntStatus now)
Interrupt::ChangeLevel	machine/interrupt.h	/^    void ChangeLevel(IntStatus old, 	\/\/ SetLevel, without advancing the$/;"	p	class:Interrupt	access:private	signature:(IntStatus old, IntStatus now)
Interrupt::CheckIfDue	machine/interrupt.cc	/^Interrupt::CheckIfDue(bool advanceClock)$/;"	f	class:Interrupt	signature:(bool advanceClock)
Interrupt::CheckIfDue	machine/interrupt.h	/^    bool CheckIfDue(bool advanceClock); $/;"	p	class:Interrupt	access:private	signature:(bool advanceClock)
Interrupt::DumpState	machine/interrupt.cc	/^Interrupt::DumpState()$/;"	f	class:Interrupt	signature:()
Interrupt::DumpState	machine/interrupt.h	/^    void DumpState();		\/\/ Print interrupt state$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Enable	machine/interrupt.h	/^    void Enable() { (void) SetLevel(IntOn); }$/;"	f	class:Interrupt	access:public	signature:()
Interrupt::Halt	machine/interrupt.cc	/^Interrupt::Halt()$/;"	f	class:Interrupt	signature:()
Interrupt::Halt	machine/interrupt.h	/^    void Halt(); 		\/\/ quit and print out stats$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Idle	machine/interrupt.cc	/^Interrupt::Idle()$/;"	f	class:Interrupt	signature:()
Interrupt::Idle	machine/interrupt.h	/^    void Idle(); 		\/\/ The ready queue is empty, roll $/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Interrupt	machine/interrupt.cc	/^Interrupt::Interrupt()$/;"	f	class:Interrupt	signature:()
Interrupt::Interrupt	machine/interrupt.h	/^    Interrupt();		\/\/ initialize the interrupt simulation$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::OneTick	machine/interrupt.cc	/^Interrupt::OneTick()$/;"	f	class:Interrupt	signature:()
Interrupt::OneTick	machine/interrupt.h	/^    void OneTick();       	\/\/ Advance simulated time$/;"	p	class:Interrupt	access:public	signature:()
Interrupt::Schedule	machine/interrupt.cc	/^Interrupt::Schedule(CallBackObj *toCall, int fromNow, IntType type)$/;"	f	class:Interrupt	signature:(CallBackObj *toCall, int fromNow, IntType type)
Interrupt::Schedule	machine/interrupt.h	/^    void Schedule(CallBackObj *callTo, int when, IntType type);$/;"	p	class:Interrupt	access:public	signature:(CallBackObj *callTo, int when, IntType type)
Interrupt::SetLevel	machine/interrupt.cc	/^Interrupt::SetLevel(IntStatus now)$/;"	f	class:Interrupt	signature:(IntStatus now)
Interrupt::SetLevel	machine/interrupt.h	/^    IntStatus SetLevel(IntStatus level);$/;"	p	class:Interrupt	access:public	signature:(IntStatus level)
Interrupt::YieldOnReturn	machine/interrupt.cc	/^Interrupt::YieldOnReturn()$/;"	f	class:Interrupt	signature:()
Interrupt::YieldOnReturn	machine/interrupt.h	/^    void YieldOnReturn();	\/\/ cause a context switch on return $/;"	p	class:Interrupt	access:public	signature:()
Interrupt::getLevel	machine/interrupt.h	/^    IntStatus getLevel() {return level;}$/;"	f	class:Interrupt	access:public	signature:()
Interrupt::getStatus	machine/interrupt.h	/^    MachineStatus getStatus() { return status; } $/;"	f	class:Interrupt	access:public	signature:()
Interrupt::inHandler	machine/interrupt.h	/^    bool inHandler;		\/\/ TRUE if we are running an interrupt handler$/;"	m	class:Interrupt	access:private
Interrupt::level	machine/interrupt.h	/^    IntStatus level;		\/\/ are interrupts enabled or disabled?$/;"	m	class:Interrupt	access:private
Interrupt::pending	machine/interrupt.h	/^    SortedList<PendingInterrupt *> *pending;		$/;"	m	class:Interrupt	access:private
Interrupt::setStatus	machine/interrupt.h	/^    void setStatus(MachineStatus st) { status = st; }$/;"	f	class:Interrupt	access:public	signature:(MachineStatus st)
Interrupt::status	machine/interrupt.h	/^    MachineStatus status;	\/\/ idle, kernel mode, user mode$/;"	m	class:Interrupt	access:private
Interrupt::yieldOnReturn	machine/interrupt.h	/^    bool yieldOnReturn; 	\/\/ TRUE if we are to context switch$/;"	m	class:Interrupt	access:private
Interrupt::~Interrupt	machine/interrupt.cc	/^Interrupt::~Interrupt()$/;"	f	class:Interrupt	signature:()
Interrupt::~Interrupt	machine/interrupt.h	/^    ~Interrupt();		\/\/ de-allocate data structures$/;"	p	class:Interrupt	access:public	signature:()
IsDone	lib/hash.h	/^    bool IsDone() { return (bucket == table->numBuckets); };$/;"	f	class:HashIterator	access:public	signature:()
IsDone	lib/list.h	/^    bool IsDone() { return current == NULL; };$/;"	f	class:ListIterator	access:public	signature:()
IsEmpty	lib/hash.h	/^    bool IsEmpty() { return numItems == 0; }	$/;"	f	class:HashTable	access:public	signature:()
IsEmpty	lib/list.h	/^    bool IsEmpty() { return (numInList == 0); };$/;"	f	class:List	access:public	signature:()
IsEnabled	lib/debug.cc	/^Debug::IsEnabled(char flag)$/;"	f	class:Debug	signature:(char flag)
IsEnabled	lib/debug.h	/^    bool IsEnabled(char flag);$/;"	p	class:Debug	access:public	signature:(char flag)
IsHeldByCurrentThread	threads/synch.h	/^    bool IsHeldByCurrentThread() { $/;"	f	class:Lock	access:public	signature:()
IsInList	lib/list.cc	/^List<T>::IsInList(T item) const$/;"	f	class:List	signature:(T item) const
IsInList	lib/list.h	/^    bool IsInList(T item) const;\/\/ is the item in the list?$/;"	p	class:List	access:public	signature:(T item) const
IsInTable	lib/hash.h	/^    bool IsInTable(Key key) { T dummy; return Find(key, &dummy); } 	$/;"	f	class:HashTable	access:public	signature:(Key key)
Item	lib/hash.h	/^    T Item() { ASSERT(!IsDone()); return bucketIter->Item(); }; $/;"	f	class:HashIterator	access:public	signature:()
Item	lib/list.h	/^    T Item() { ASSERT(!IsDone()); return current->item; };$/;"	f	class:ListIterator	access:public	signature:()
JFMT	machine/mipssim.h	109;"	d
JUST_CREATED	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
Join	test/start.S	/^Join:$/;"	l
Join	userprog/syscall.h	/^int Join(SpaceId id); 	$/;"	p	signature:(SpaceId id)
KERNEL_H	threads/kernel.h	9;"	d
Kernel	threads/kernel.cc	/^Kernel::Kernel(int argc, char **argv)$/;"	f	class:Kernel	signature:(int argc, char **argv)
Kernel	threads/kernel.h	/^    Kernel(int argc, char **argv);$/;"	p	class:Kernel	access:public	signature:(int argc, char **argv)
Kernel	threads/kernel.h	/^class Kernel {$/;"	c
Kernel::ConsoleTest	threads/kernel.cc	/^Kernel::ConsoleTest() {$/;"	f	class:Kernel	signature:()
Kernel::ConsoleTest	threads/kernel.h	/^    void ConsoleTest();         \/\/ interactive console self test$/;"	p	class:Kernel	access:public	signature:()
Kernel::Initialize	threads/kernel.cc	/^Kernel::Initialize()$/;"	f	class:Kernel	signature:()
Kernel::Initialize	threads/kernel.h	/^    void Initialize(); 		\/\/ initialize the kernel -- separated$/;"	p	class:Kernel	access:public	signature:()
Kernel::Kernel	threads/kernel.cc	/^Kernel::Kernel(int argc, char **argv)$/;"	f	class:Kernel	signature:(int argc, char **argv)
Kernel::Kernel	threads/kernel.h	/^    Kernel(int argc, char **argv);$/;"	p	class:Kernel	access:public	signature:(int argc, char **argv)
Kernel::NetworkTest	threads/kernel.cc	/^Kernel::NetworkTest() {$/;"	f	class:Kernel	signature:()
Kernel::NetworkTest	threads/kernel.h	/^    void NetworkTest();         \/\/ interactive 2-machine network test$/;"	p	class:Kernel	access:public	signature:()
Kernel::ThreadSelfTest	threads/kernel.cc	/^Kernel::ThreadSelfTest() {$/;"	f	class:Kernel	signature:()
Kernel::ThreadSelfTest	threads/kernel.h	/^    void ThreadSelfTest();	\/\/ self test of threads and synchronization$/;"	p	class:Kernel	access:public	signature:()
Kernel::alarm	threads/kernel.h	/^    Alarm *alarm;		\/\/ the software alarm clock    $/;"	m	class:Kernel	access:public
Kernel::consoleIn	threads/kernel.h	/^    char *consoleIn;            \/\/ file to read console input from$/;"	m	class:Kernel	access:private
Kernel::consoleOut	threads/kernel.h	/^    char *consoleOut;           \/\/ file to send console output to$/;"	m	class:Kernel	access:private
Kernel::currentThread	threads/kernel.h	/^    Thread *currentThread;	\/\/ the thread holding the CPU$/;"	m	class:Kernel	access:public
Kernel::debugUserProg	threads/kernel.h	/^    bool debugUserProg;         \/\/ single step user program$/;"	m	class:Kernel	access:private
Kernel::fileSystem	threads/kernel.h	/^    FileSystem *fileSystem;     $/;"	m	class:Kernel	access:public
Kernel::formatFlag	threads/kernel.h	/^    bool formatFlag;          \/\/ format the disk if this is true$/;"	m	class:Kernel	access:private
Kernel::hostName	threads/kernel.h	/^    int hostName;               \/\/ machine identifier$/;"	m	class:Kernel	access:public
Kernel::interrupt	threads/kernel.h	/^    Interrupt *interrupt;	\/\/ interrupt status$/;"	m	class:Kernel	access:public
Kernel::machine	threads/kernel.h	/^    Machine *machine;           \/\/ the simulated CPU$/;"	m	class:Kernel	access:public
Kernel::postOfficeIn	threads/kernel.h	/^    PostOfficeInput *postOfficeIn;$/;"	m	class:Kernel	access:public
Kernel::postOfficeOut	threads/kernel.h	/^    PostOfficeOutput *postOfficeOut;$/;"	m	class:Kernel	access:public
Kernel::randomSlice	threads/kernel.h	/^    bool randomSlice;		\/\/ enable pseudo-random time slicing$/;"	m	class:Kernel	access:private
Kernel::reliability	threads/kernel.h	/^    double reliability;         \/\/ likelihood messages are dropped$/;"	m	class:Kernel	access:private
Kernel::scheduler	threads/kernel.h	/^    Scheduler *scheduler;	\/\/ the ready list$/;"	m	class:Kernel	access:public
Kernel::stats	threads/kernel.h	/^    Statistics *stats;		\/\/ performance metrics$/;"	m	class:Kernel	access:public
Kernel::synchConsoleIn	threads/kernel.h	/^    SynchConsoleInput *synchConsoleIn;$/;"	m	class:Kernel	access:public
Kernel::synchConsoleOut	threads/kernel.h	/^    SynchConsoleOutput *synchConsoleOut;$/;"	m	class:Kernel	access:public
Kernel::synchDisk	threads/kernel.h	/^    SynchDisk *synchDisk;$/;"	m	class:Kernel	access:public
Kernel::~Kernel	threads/kernel.cc	/^Kernel::~Kernel()$/;"	f	class:Kernel	signature:()
Kernel::~Kernel	threads/kernel.h	/^    ~Kernel();		        \/\/ deallocate the kernel$/;"	p	class:Kernel	access:public	signature:()
LD	build.cygwin/Makefile	/^LD = g++$/;"	m
LD	build.linux/Makefile	/^LD = g++$/;"	m
LD	build.macosx/Makefile	/^LD = g++$/;"	m
LD	test/Makefile	/^LD = $(GCCDIR)ld$/;"	m
LDFLAGS	build.cygwin/Makefile	/^LDFLAGS =$/;"	m
LDFLAGS	build.linux/Makefile	/^LDFLAGS = -m32$/;"	m
LDFLAGS	build.macosx/Makefile	/^LDFLAGS =$/;"	m
LIBTEST_H	lib/libtest.h	9;"	d
LIB_C	build.cygwin/Makefile	/^LIB_C = ..\/lib\/bitmap.cc\\$/;"	m
LIB_C	build.linux/Makefile	/^LIB_C = ..\/lib\/bitmap.cc\\$/;"	m
LIB_C	build.macosx/Makefile	/^LIB_C = ..\/lib\/bitmap.cc\\$/;"	m
LIB_H	build.cygwin/Makefile	/^LIB_H = ..\/lib\/bitmap.h\\$/;"	m
LIB_H	build.linux/Makefile	/^LIB_H = ..\/lib\/bitmap.h\\$/;"	m
LIB_H	build.macosx/Makefile	/^LIB_H = ..\/lib\/bitmap.h\\$/;"	m
LIB_O	build.cygwin/Makefile	/^LIB_O = bitmap.o debug.o libtest.o sysdep.o$/;"	m
LIB_O	build.linux/Makefile	/^LIB_O = bitmap.o debug.o libtest.o sysdep.o$/;"	m
LIB_O	build.macosx/Makefile	/^LIB_O = bitmap.o debug.o libtest.o sysdep.o$/;"	m
LIST_H	lib/list.h	14;"	d
LR	threads/switch.h	204;"	d
Length	filesys/openfile.cc	/^OpenFile::Length() $/;"	f	class:OpenFile	signature:()
Length	filesys/openfile.h	/^    int Length() { Lseek(file, 0, 2); return Tell(file); }$/;"	f	class:OpenFile	access:public	signature:()
Length	filesys/openfile.h	/^    int Length(); 			\/\/ Return the number of bytes in the$/;"	p	class:OpenFile	access:public	signature:()
LibSelfTest	lib/libtest.cc	/^LibSelfTest () {$/;"	f	signature:()
LibSelfTest	lib/libtest.h	/^extern void LibSelfTest();$/;"	p	signature:()
List	filesys/directory.cc	/^Directory::List()$/;"	f	class:Directory	signature:()
List	filesys/directory.h	/^    void List();			\/\/ Print the names of all the files$/;"	p	class:Directory	access:public	signature:()
List	filesys/filesys.cc	/^FileSystem::List()$/;"	f	class:FileSystem	signature:()
List	filesys/filesys.h	/^    void List();			\/\/ List all the files in the file system$/;"	p	class:FileSystem	access:public	signature:()
List	lib/list.cc	/^List<T>::List()$/;"	f	class:List	signature:()
List	lib/list.h	/^    List();			\/\/ initialize the list$/;"	p	class:List	access:public	signature:()
List	lib/list.h	/^class List {$/;"	c
List::Append	lib/list.cc	/^List<T>::Append(T item)$/;"	f	class:List	signature:(T item)
List::Append	lib/list.h	/^    virtual void Append(T item); \/\/ Put item at the end of the list$/;"	p	class:List	access:public	signature:(T item)
List::Apply	lib/list.cc	/^List<T>::Apply(void (*func)(T)) const$/;"	f	class:List	signature:(void (*func)(T)) const
List::Apply	lib/list.h	/^    void Apply(void (*f)(T)) const; $/;"	p	class:List	access:public	signature:(void (*f)(T)) const
List::Front	lib/list.h	/^    T Front() { return first->item; }$/;"	f	class:List	access:public	signature:()
List::IsEmpty	lib/list.h	/^    bool IsEmpty() { return (numInList == 0); };$/;"	f	class:List	access:public	signature:()
List::IsInList	lib/list.cc	/^List<T>::IsInList(T item) const$/;"	f	class:List	signature:(T item) const
List::IsInList	lib/list.h	/^    bool IsInList(T item) const;\/\/ is the item in the list?$/;"	p	class:List	access:public	signature:(T item) const
List::List	lib/list.cc	/^List<T>::List()$/;"	f	class:List	signature:()
List::List	lib/list.h	/^    List();			\/\/ initialize the list$/;"	p	class:List	access:public	signature:()
List::NumInList	lib/list.h	/^    unsigned int NumInList() { return numInList;};$/;"	f	class:List	access:public	signature:()
List::Prepend	lib/list.cc	/^List<T>::Prepend(T item)$/;"	f	class:List	signature:(T item)
List::Prepend	lib/list.h	/^    virtual void Prepend(T item);\/\/ Put item at the beginning of the list$/;"	p	class:List	access:public	signature:(T item)
List::Remove	lib/list.cc	/^List<T>::Remove(T item)$/;"	f	class:List	signature:(T item)
List::Remove	lib/list.h	/^    void Remove(T item); 	\/\/ Remove specific item from list$/;"	p	class:List	access:public	signature:(T item)
List::RemoveFront	lib/list.cc	/^List<T>::RemoveFront()$/;"	f	class:List	signature:()
List::RemoveFront	lib/list.h	/^    T RemoveFront(); 		\/\/ Take item off the front of the list$/;"	p	class:List	access:public	signature:()
List::SanityCheck	lib/list.cc	/^List<T>::SanityCheck() const$/;"	f	class:List	signature:() const
List::SanityCheck	lib/list.h	/^    virtual void SanityCheck() const;	$/;"	p	class:List	access:public	signature:() const
List::SelfTest	lib/list.cc	/^List<T>::SelfTest(T *p, int numEntries)$/;"	f	class:List	signature:(T *p, int numEntries)
List::SelfTest	lib/list.h	/^    void SelfTest(T *p, int numEntries);$/;"	p	class:List	access:public	signature:(T *p, int numEntries)
List::first	lib/list.h	/^    ListElement<T> *first;  	\/\/ Head of the list, NULL if list is empty$/;"	m	class:List	access:protected
List::last	lib/list.h	/^    ListElement<T> *last;	\/\/ Last element of list$/;"	m	class:List	access:protected
List::numInList	lib/list.h	/^    int numInList;		\/\/ number of elements in list$/;"	m	class:List	access:protected
List::~List	lib/list.cc	/^List<T>::~List()$/;"	f	class:List	signature:()
List::~List	lib/list.h	/^    virtual ~List();		\/\/ de-allocate the list$/;"	p	class:List	access:public	signature:()
ListElement	lib/list.cc	/^ListElement<T>::ListElement(T itm)$/;"	f	class:ListElement	signature:(T itm)
ListElement	lib/list.h	/^    ListElement(T itm); 	\/\/ initialize a list element$/;"	p	class:ListElement	access:public	signature:(T itm)
ListElement	lib/list.h	/^class ListElement {$/;"	c
ListElement::ListElement	lib/list.cc	/^ListElement<T>::ListElement(T itm)$/;"	f	class:ListElement	signature:(T itm)
ListElement::ListElement	lib/list.h	/^    ListElement(T itm); 	\/\/ initialize a list element$/;"	p	class:ListElement	access:public	signature:(T itm)
ListElement::item	lib/list.h	/^    T item; 	   	     	\/\/ item on the list$/;"	m	class:ListElement	access:public
ListElement::next	lib/list.h	/^    ListElement *next;	     	\/\/ next element on list, NULL if this is last$/;"	m	class:ListElement	access:public
ListIterator	lib/list.h	/^    ListIterator(List<T> *list) { current = list->first; } $/;"	f	class:ListIterator	access:public	signature:(List<T> *list)
ListIterator	lib/list.h	/^class ListIterator {$/;"	c
ListIterator::IsDone	lib/list.h	/^    bool IsDone() { return current == NULL; };$/;"	f	class:ListIterator	access:public	signature:()
ListIterator::Item	lib/list.h	/^    T Item() { ASSERT(!IsDone()); return current->item; };$/;"	f	class:ListIterator	access:public	signature:()
ListIterator::ListIterator	lib/list.h	/^    ListIterator(List<T> *list) { current = list->first; } $/;"	f	class:ListIterator	access:public	signature:(List<T> *list)
ListIterator::Next	lib/list.h	/^    void Next() { current = current->next; };		$/;"	f	class:ListIterator	access:public	signature:()
ListIterator::current	lib/list.h	/^    ListElement<T> *current;	\/\/ where we are in the list$/;"	m	class:ListIterator	access:private
LoReg	machine/machine.h	68;"	d
Load	userprog/addrspace.cc	/^AddrSpace::Load(char *fileName) $/;"	f	class:AddrSpace	signature:(char *fileName)
Load	userprog/addrspace.h	/^    bool Load(char *fileName);		\/\/ Load a program into addr space from$/;"	p	class:AddrSpace	access:public	signature:(char *fileName)
LoadReg	machine/machine.h	72;"	d
LoadValueReg	machine/machine.h	73;"	d
Lock	threads/synch.cc	/^Lock::Lock(char* debugName)$/;"	f	class:Lock	signature:(char* debugName)
Lock	threads/synch.h	/^    Lock(char* debugName);  	\/\/ initialize lock to be FREE$/;"	p	class:Lock	access:public	signature:(char* debugName)
Lock	threads/synch.h	/^class Lock {$/;"	c
Lock::Acquire	threads/synch.cc	/^void Lock::Acquire()$/;"	f	class:Lock	signature:()
Lock::Acquire	threads/synch.h	/^    void Acquire(); 		\/\/ these are the only operations on a lock$/;"	p	class:Lock	access:public	signature:()
Lock::IsHeldByCurrentThread	threads/synch.h	/^    bool IsHeldByCurrentThread() { $/;"	f	class:Lock	access:public	signature:()
Lock::Lock	threads/synch.cc	/^Lock::Lock(char* debugName)$/;"	f	class:Lock	signature:(char* debugName)
Lock::Lock	threads/synch.h	/^    Lock(char* debugName);  	\/\/ initialize lock to be FREE$/;"	p	class:Lock	access:public	signature:(char* debugName)
Lock::Release	threads/synch.cc	/^void Lock::Release()$/;"	f	class:Lock	signature:()
Lock::Release	threads/synch.h	/^    void Release(); 		\/\/ they are both *atomic*$/;"	p	class:Lock	access:public	signature:()
Lock::getName	threads/synch.h	/^    char* getName() { return name; }	\/\/ debugging assist$/;"	f	class:Lock	access:public	signature:()
Lock::lockHolder	threads/synch.h	/^    Thread *lockHolder;		\/\/ thread currently holding lock$/;"	m	class:Lock	access:private
Lock::name	threads/synch.h	/^    char *name;			\/\/ debugging assist$/;"	m	class:Lock	access:private
Lock::semaphore	threads/synch.h	/^    Semaphore *semaphore;	\/\/ we use a semaphore to implement lock$/;"	m	class:Lock	access:private
Lock::~Lock	threads/synch.cc	/^Lock::~Lock()$/;"	f	class:Lock	signature:()
Lock::~Lock	threads/synch.h	/^    ~Lock();			\/\/ deallocate lock$/;"	p	class:Lock	access:public	signature:()
Lseek	lib/sysdep.cc	/^Lseek(int fd, int offset, int whence)$/;"	f	signature:(int fd, int offset, int whence)
Lseek	lib/sysdep.h	/^extern void Lseek(int fd, int offset, int whence);$/;"	p	signature:(int fd, int offset, int whence)
MACHINE_C	build.cygwin/Makefile	/^MACHINE_C = ..\/machine\/interrupt.cc\\$/;"	m
MACHINE_C	build.linux/Makefile	/^MACHINE_C = ..\/machine\/interrupt.cc\\$/;"	m
MACHINE_C	build.macosx/Makefile	/^MACHINE_C = ..\/machine\/interrupt.cc\\$/;"	m
MACHINE_H	build.cygwin/Makefile	/^MACHINE_H = ..\/machine\/callback.h\\$/;"	m
MACHINE_H	build.linux/Makefile	/^MACHINE_H = ..\/machine\/callback.h\\$/;"	m
MACHINE_H	build.macosx/Makefile	/^MACHINE_H = ..\/machine\/callback.h\\$/;"	m
MACHINE_H	machine/machine.h	22;"	d
MACHINE_O	build.cygwin/Makefile	/^MACHINE_O = interrupt.o stats.o timer.o console.o machine.o mipssim.o\\$/;"	m
MACHINE_O	build.linux/Makefile	/^MACHINE_O = interrupt.o stats.o timer.o console.o machine.o mipssim.o\\$/;"	m
MACHINE_O	build.macosx/Makefile	/^MACHINE_O = interrupt.o stats.o timer.o console.o machine.o mipssim.o\\$/;"	m
MAIN	threads/main.cc	40;"	d	file:
MAIN	threads/main.cc	42;"	d	file:
MAIN_H	threads/main.h	9;"	d
MIPSSIM_H	machine/mipssim.h	11;"	d
Machine	machine/machine.cc	/^Machine::Machine(bool debug)$/;"	f	class:Machine	signature:(bool debug)
Machine	machine/machine.h	/^    Machine(bool debug);	\/\/ Initialize the simulation of the hardware$/;"	p	class:Machine	access:public	signature:(bool debug)
Machine	machine/machine.h	/^class Machine {$/;"	c
Machine::Debugger	machine/machine.cc	/^void Machine::Debugger()$/;"	f	class:Machine	signature:()
Machine::Debugger	machine/machine.h	/^    void Debugger();		\/\/ invoke the user program debugger$/;"	p	class:Machine	access:private	signature:()
Machine::DelayedLoad	machine/machine.h	/^    void DelayedLoad(int nextReg, int nextVal);  	$/;"	p	class:Machine	access:private	signature:(int nextReg, int nextVal)
Machine::DelayedLoad	machine/mipssim.cc	/^Machine::DelayedLoad(int nextReg, int nextValue)$/;"	f	class:Machine	signature:(int nextReg, int nextValue)
Machine::DumpState	machine/machine.cc	/^Machine::DumpState()$/;"	f	class:Machine	signature:()
Machine::DumpState	machine/machine.h	/^    void DumpState();		\/\/ print the user CPU and memory state $/;"	p	class:Machine	access:private	signature:()
Machine::Machine	machine/machine.cc	/^Machine::Machine(bool debug)$/;"	f	class:Machine	signature:(bool debug)
Machine::Machine	machine/machine.h	/^    Machine(bool debug);	\/\/ Initialize the simulation of the hardware$/;"	p	class:Machine	access:public	signature:(bool debug)
Machine::OneInstruction	machine/machine.h	/^    void OneInstruction(Instruction *instr); 	$/;"	p	class:Machine	access:private	signature:(Instruction *instr)
Machine::OneInstruction	machine/mipssim.cc	/^Machine::OneInstruction(Instruction *instr)$/;"	f	class:Machine	signature:(Instruction *instr)
Machine::RaiseException	machine/machine.cc	/^Machine::RaiseException(ExceptionType which, int badVAddr)$/;"	f	class:Machine	signature:(ExceptionType which, int badVAddr)
Machine::RaiseException	machine/machine.h	/^    void RaiseException(ExceptionType which, int badVAddr);$/;"	p	class:Machine	access:private	signature:(ExceptionType which, int badVAddr)
Machine::ReadMem	machine/machine.h	/^    bool ReadMem(int addr, int size, int* value);$/;"	p	class:Machine	access:public	signature:(int addr, int size, int* value)
Machine::ReadMem	machine/translate.cc	/^Machine::ReadMem(int addr, int size, int *value)$/;"	f	class:Machine	signature:(int addr, int size, int *value)
Machine::ReadRegister	machine/machine.cc	/^Machine::ReadRegister(int num)$/;"	f	class:Machine	signature:(int num)
Machine::ReadRegister	machine/machine.h	/^    int ReadRegister(int num);	\/\/ read the contents of a CPU register$/;"	p	class:Machine	access:public	signature:(int num)
Machine::Run	machine/machine.h	/^    void Run();	 		\/\/ Run a user program$/;"	p	class:Machine	access:public	signature:()
Machine::Run	machine/mipssim.cc	/^Machine::Run()$/;"	f	class:Machine	signature:()
Machine::Translate	machine/machine.h	/^    ExceptionType Translate(int virtAddr, int* physAddr, int size,bool writing);$/;"	p	class:Machine	access:private	signature:(int virtAddr, int* physAddr, int size,bool writing)
Machine::Translate	machine/translate.cc	/^Machine::Translate(int virtAddr, int* physAddr, int size, bool writing)$/;"	f	class:Machine	signature:(int virtAddr, int* physAddr, int size, bool writing)
Machine::WriteMem	machine/machine.h	/^    bool WriteMem(int addr, int size, int value);$/;"	p	class:Machine	access:public	signature:(int addr, int size, int value)
Machine::WriteMem	machine/translate.cc	/^Machine::WriteMem(int addr, int size, int value)$/;"	f	class:Machine	signature:(int addr, int size, int value)
Machine::WriteRegister	machine/machine.cc	/^Machine::WriteRegister(int num, int value)$/;"	f	class:Machine	signature:(int num, int value)
Machine::WriteRegister	machine/machine.h	/^    void WriteRegister(int num, int value);$/;"	p	class:Machine	access:public	signature:(int num, int value)
Machine::mainMemory	machine/machine.h	/^    char *mainMemory;		\/\/ physical memory to store user program,$/;"	m	class:Machine	access:public
Machine::pageTable	machine/machine.h	/^    TranslationEntry *pageTable;$/;"	m	class:Machine	access:public
Machine::pageTableSize	machine/machine.h	/^    unsigned int pageTableSize;$/;"	m	class:Machine	access:public
Machine::registers	machine/machine.h	/^    int registers[NumTotalRegs]; \/\/ CPU registers, for executing user programs$/;"	m	class:Machine	access:private
Machine::runUntilTime	machine/machine.h	/^    int runUntilTime;		\/\/ drop back into the debugger when simulated$/;"	m	class:Machine	access:private
Machine::singleStep	machine/machine.h	/^    bool singleStep;		\/\/ drop back into the debugger after each$/;"	m	class:Machine	access:private
Machine::tlb	machine/machine.h	/^    TranslationEntry *tlb;		\/\/ this pointer should be considered $/;"	m	class:Machine	access:public
Machine::~Machine	machine/machine.cc	/^Machine::~Machine()$/;"	f	class:Machine	signature:()
Machine::~Machine	machine/machine.h	/^    ~Machine();			\/\/ De-allocate the data structures$/;"	p	class:Machine	access:public	signature:()
MachineStateSize	threads/thread.h	54;"	d
MachineStatus	machine/interrupt.h	/^enum MachineStatus {IdleMode, SystemMode, UserMode};$/;"	g
MagicNumber	machine/disk.cc	/^const int MagicNumber = 0x456789ab;$/;"	v
MagicSize	machine/disk.cc	/^const int MagicSize = sizeof(int);$/;"	v
Mail	network/post.cc	/^Mail::Mail(PacketHeader pktH, MailHeader mailH, char *msgData)$/;"	f	class:Mail	signature:(PacketHeader pktH, MailHeader mailH, char *msgData)
Mail	network/post.h	/^     Mail(PacketHeader pktH, MailHeader mailH, char *msgData);$/;"	p	class:Mail	access:public	signature:(PacketHeader pktH, MailHeader mailH, char *msgData)
Mail	network/post.h	/^class Mail {$/;"	c
Mail::Mail	network/post.cc	/^Mail::Mail(PacketHeader pktH, MailHeader mailH, char *msgData)$/;"	f	class:Mail	signature:(PacketHeader pktH, MailHeader mailH, char *msgData)
Mail::Mail	network/post.h	/^     Mail(PacketHeader pktH, MailHeader mailH, char *msgData);$/;"	p	class:Mail	access:public	signature:(PacketHeader pktH, MailHeader mailH, char *msgData)
Mail::data	network/post.h	/^     char data[MaxMailSize];	\/\/ Payload -- message data$/;"	m	class:Mail	access:public
Mail::mailHdr	network/post.h	/^     MailHeader mailHdr;	\/\/ Header appended by PostOffice$/;"	m	class:Mail	access:public
Mail::pktHdr	network/post.h	/^     PacketHeader pktHdr;	\/\/ Header appended by Network$/;"	m	class:Mail	access:public
MailBox	network/post.cc	/^MailBox::MailBox()$/;"	f	class:MailBox	signature:()
MailBox	network/post.h	/^    MailBox();			\/\/ Allocate and initialize mail box$/;"	p	class:MailBox	access:public	signature:()
MailBox	network/post.h	/^class MailBox {$/;"	c
MailBox::Get	network/post.cc	/^MailBox::Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data) $/;"	f	class:MailBox	signature:(PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
MailBox::Get	network/post.h	/^    void Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data); $/;"	p	class:MailBox	access:public	signature:(PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
MailBox::MailBox	network/post.cc	/^MailBox::MailBox()$/;"	f	class:MailBox	signature:()
MailBox::MailBox	network/post.h	/^    MailBox();			\/\/ Allocate and initialize mail box$/;"	p	class:MailBox	access:public	signature:()
MailBox::Put	network/post.cc	/^MailBox::Put(PacketHeader pktHdr, MailHeader mailHdr, char *data)$/;"	f	class:MailBox	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
MailBox::Put	network/post.h	/^    void Put(PacketHeader pktHdr, MailHeader mailHdr, char *data);$/;"	p	class:MailBox	access:public	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
MailBox::messages	network/post.h	/^    SynchList<Mail *> *messages; \/\/ A mailbox is just a list of arrived messages$/;"	m	class:MailBox	access:private
MailBox::~MailBox	network/post.cc	/^MailBox::~MailBox()$/;"	f	class:MailBox	signature:()
MailBox::~MailBox	network/post.h	/^    ~MailBox();			\/\/ De-allocate mail box$/;"	p	class:MailBox	access:public	signature:()
MailBoxAddress	network/post.h	/^typedef int MailBoxAddress;$/;"	t
MailHeader	network/post.h	/^class MailHeader {$/;"	c
MailHeader::from	network/post.h	/^    MailBoxAddress from;	\/\/ Mail box to reply to$/;"	m	class:MailHeader	access:public
MailHeader::length	network/post.h	/^    unsigned length;		\/\/ Bytes of message data (excluding the $/;"	m	class:MailHeader	access:public
MailHeader::to	network/post.h	/^    MailBoxAddress to;		\/\/ Destination mail box$/;"	m	class:MailHeader	access:public
Mark	lib/bitmap.cc	/^Bitmap::Mark(int which) $/;"	f	class:Bitmap	signature:(int which)
Mark	lib/bitmap.h	/^    void Mark(int which);   	\/\/ Set the "nth" bit$/;"	p	class:Bitmap	access:public	signature:(int which)
MaxFileSize	filesys/filehdr.h	21;"	d
MaxMailSize	network/post.h	56;"	d
MaxOpcode	machine/mipssim.h	88;"	d
MaxPacketSize	machine/network.h	42;"	d
MaxWireSize	machine/network.h	41;"	d
MemorySize	machine/machine.h	/^const int MemorySize = (NumPhysPages * PageSize);$/;"	v
ModuloDiff	machine/disk.cc	/^Disk::ModuloDiff(int to, int from)$/;"	f	class:Disk	signature:(int to, int from)
ModuloDiff	machine/disk.h	/^    int ModuloDiff(int to, int from);        \/\/ # sectors between to and from$/;"	p	class:Disk	access:private	signature:(int to, int from)
Mult	machine/mipssim.cc	/^Mult(int a, int b, bool signedArith, int* hiPtr, int* loPtr)$/;"	f	file:	signature:(int a, int b, bool signedArith, int* hiPtr, int* loPtr)
Mult	machine/mipssim.cc	/^static void Mult(int a, int b, bool signedArith, int* hiPtr, int* loPtr);$/;"	p	file:	signature:(int a, int b, bool signedArith, int* hiPtr, int* loPtr)
N	test/segments.c	17;"	d	file:
NETWORK_C	build.cygwin/Makefile	/^NETWORK_C = ..\/network\/post.cc$/;"	m
NETWORK_C	build.linux/Makefile	/^NETWORK_C = ..\/network\/post.cc$/;"	m
NETWORK_C	build.macosx/Makefile	/^NETWORK_C = ..\/network\/post.cc$/;"	m
NETWORK_H	build.cygwin/Makefile	/^NETWORK_H = ..\/network\/post.h$/;"	m
NETWORK_H	build.linux/Makefile	/^NETWORK_H = ..\/network\/post.h$/;"	m
NETWORK_H	build.macosx/Makefile	/^NETWORK_H = ..\/network\/post.h$/;"	m
NETWORK_H	machine/network.h	16;"	d
NETWORK_O	build.cygwin/Makefile	/^NETWORK_O = post.o$/;"	m
NETWORK_O	build.linux/Makefile	/^NETWORK_O = post.o$/;"	m
NETWORK_O	build.macosx/Makefile	/^NETWORK_O = post.o$/;"	m
NOFFMAGIC	userprog/noff.h	8;"	d
NONE	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
NO_MPROT	lib/sysdep.cc	44;"	d	file:
NO_MPROT	lib/sysdep.cc	47;"	d	file:
NULL	lib/utility.h	15;"	d
NetworkAddress	machine/network.h	/^typedef int NetworkAddress;	 $/;"	t
NetworkInput	machine/network.cc	/^NetworkInput::NetworkInput(CallBackObj *toCall)$/;"	f	class:NetworkInput	signature:(CallBackObj *toCall)
NetworkInput	machine/network.h	/^    NetworkInput(CallBackObj *toCall);$/;"	p	class:NetworkInput	access:public	signature:(CallBackObj *toCall)
NetworkInput	machine/network.h	/^class NetworkInput : public CallBackObj{$/;"	c	inherits:CallBackObj
NetworkInput::CallBack	machine/network.cc	/^NetworkInput::CallBack()$/;"	f	class:NetworkInput	signature:()
NetworkInput::CallBack	machine/network.h	/^    void CallBack();		\/\/ A packet may have arrived.$/;"	p	class:NetworkInput	access:public	signature:()
NetworkInput::NetworkInput	machine/network.cc	/^NetworkInput::NetworkInput(CallBackObj *toCall)$/;"	f	class:NetworkInput	signature:(CallBackObj *toCall)
NetworkInput::NetworkInput	machine/network.h	/^    NetworkInput(CallBackObj *toCall);$/;"	p	class:NetworkInput	access:public	signature:(CallBackObj *toCall)
NetworkInput::Receive	machine/network.cc	/^NetworkInput::Receive(char* data)$/;"	f	class:NetworkInput	signature:(char* data)
NetworkInput::Receive	machine/network.h	/^    PacketHeader Receive(char* data);$/;"	p	class:NetworkInput	access:public	signature:(char* data)
NetworkInput::callWhenAvail	machine/network.h	/^    CallBackObj *callWhenAvail; \/\/ Interrupt handler, signalling packet has $/;"	m	class:NetworkInput	access:private
NetworkInput::inHdr	machine/network.h	/^    PacketHeader inHdr;		\/\/ Information about arrived packet$/;"	m	class:NetworkInput	access:private
NetworkInput::inbox	machine/network.h	/^    char inbox[MaxPacketSize];  \/\/ Data for arrived packet$/;"	m	class:NetworkInput	access:private
NetworkInput::packetAvail	machine/network.h	/^    bool packetAvail;		\/\/ Packet has arrived, can be pulled off of$/;"	m	class:NetworkInput	access:private
NetworkInput::sock	machine/network.h	/^    int sock;                   \/\/ UNIX socket number for incoming packets$/;"	m	class:NetworkInput	access:private
NetworkInput::sockName	machine/network.h	/^    char sockName[32];          \/\/ File name corresponding to UNIX socket$/;"	m	class:NetworkInput	access:private
NetworkInput::~NetworkInput	machine/network.cc	/^NetworkInput::~NetworkInput()$/;"	f	class:NetworkInput	signature:()
NetworkInput::~NetworkInput	machine/network.h	/^    ~NetworkInput();		\/\/ De-allocate the network input driver data$/;"	p	class:NetworkInput	access:public	signature:()
NetworkOutput	machine/network.cc	/^NetworkOutput::NetworkOutput(double reliability, CallBackObj *toCall)$/;"	f	class:NetworkOutput	signature:(double reliability, CallBackObj *toCall)
NetworkOutput	machine/network.h	/^    NetworkOutput(double reliability, CallBackObj *toCall);$/;"	p	class:NetworkOutput	access:public	signature:(double reliability, CallBackObj *toCall)
NetworkOutput	machine/network.h	/^class NetworkOutput : public CallBackObj {$/;"	c	inherits:CallBackObj
NetworkOutput::CallBack	machine/network.cc	/^NetworkOutput::CallBack()$/;"	f	class:NetworkOutput	signature:()
NetworkOutput::CallBack	machine/network.h	/^    void CallBack();		\/\/ Interrupt handler, called when message is $/;"	p	class:NetworkOutput	access:public	signature:()
NetworkOutput::NetworkOutput	machine/network.cc	/^NetworkOutput::NetworkOutput(double reliability, CallBackObj *toCall)$/;"	f	class:NetworkOutput	signature:(double reliability, CallBackObj *toCall)
NetworkOutput::NetworkOutput	machine/network.h	/^    NetworkOutput(double reliability, CallBackObj *toCall);$/;"	p	class:NetworkOutput	access:public	signature:(double reliability, CallBackObj *toCall)
NetworkOutput::Send	machine/network.cc	/^NetworkOutput::Send(PacketHeader hdr, char* data)$/;"	f	class:NetworkOutput	signature:(PacketHeader hdr, char* data)
NetworkOutput::Send	machine/network.h	/^    void Send(PacketHeader hdr, char* data);$/;"	p	class:NetworkOutput	access:public	signature:(PacketHeader hdr, char* data)
NetworkOutput::callWhenDone	machine/network.h	/^    CallBackObj *callWhenDone;  \/\/ Interrupt handler, signalling next packet $/;"	m	class:NetworkOutput	access:private
NetworkOutput::chanceToWork	machine/network.h	/^    double chanceToWork;	\/\/ Likelihood packet will be dropped$/;"	m	class:NetworkOutput	access:private
NetworkOutput::sendBusy	machine/network.h	/^    bool sendBusy;		\/\/ Packet is being sent.$/;"	m	class:NetworkOutput	access:private
NetworkOutput::sock	machine/network.h	/^    int sock;                   \/\/ UNIX socket number for outgoing packets$/;"	m	class:NetworkOutput	access:private
NetworkOutput::~NetworkOutput	machine/network.cc	/^NetworkOutput::~NetworkOutput()$/;"	f	class:NetworkOutput	signature:()
NetworkOutput::~NetworkOutput	machine/network.h	/^    ~NetworkOutput();		\/\/ De-allocate the network input driver data$/;"	p	class:NetworkOutput	access:public	signature:()
NetworkRecvInt	machine/interrupt.h	/^			NetworkSendInt, NetworkRecvInt};$/;"	e	enum:IntType
NetworkSendInt	machine/interrupt.h	/^			NetworkSendInt, NetworkRecvInt};$/;"	e	enum:IntType
NetworkTest	threads/kernel.cc	/^Kernel::NetworkTest() {$/;"	f	class:Kernel	signature:()
NetworkTest	threads/kernel.h	/^    void NetworkTest();         \/\/ interactive 2-machine network test$/;"	p	class:Kernel	access:public	signature:()
NetworkTime	machine/stats.h	/^const int NetworkTime =	 100;  	\/\/ time to send or receive one packet$/;"	v
Next	lib/hash.cc	/^HashIterator<Key,T>::Next() $/;"	f	class:HashIterator	signature:()
Next	lib/hash.h	/^    void Next(); 		\/\/ update iterator to point to next$/;"	p	class:HashIterator	access:public	signature:()
Next	lib/list.h	/^    void Next() { current = current->next; };		$/;"	f	class:ListIterator	access:public	signature:()
NextPCReg	machine/machine.h	70;"	d
NoException	machine/machine.h	/^enum ExceptionType { NoException,           \/\/ Everything ok!$/;"	e	enum:ExceptionType
NoffHeader	userprog/noff.h	/^} NoffHeader;$/;"	t	typeref:struct:noffHeader
NumClear	lib/bitmap.cc	/^Bitmap::NumClear() const$/;"	f	class:Bitmap	signature:() const
NumClear	lib/bitmap.h	/^    int NumClear() const;	\/\/ Return the number of clear bits$/;"	p	class:Bitmap	access:public	signature:() const
NumDirEntries	filesys/filesys.cc	65;"	d	file:
NumDirect	filesys/filehdr.h	20;"	d
NumExceptionTypes	machine/machine.h	/^		     NumExceptionTypes$/;"	e	enum:ExceptionType
NumGPRegs	machine/machine.h	66;"	d
NumInList	lib/list.h	/^    unsigned int NumInList() { return numInList;};$/;"	f	class:List	access:public	signature:()
NumPhysPages	machine/machine.h	/^const int NumPhysPages = 128;$/;"	v
NumSectors	machine/disk.h	/^const int NumSectors = (SectorsPerTrack * NumTracks);$/;"	v
NumTotalRegs	machine/machine.h	76;"	d
NumTracks	machine/disk.h	/^const int NumTracks = 32;		\/\/ number of tracks per disk$/;"	v
OFILES	build.cygwin/Makefile	/^OFILES = $(C_OFILES) $(S_OFILES)$/;"	m
OFILES	build.linux/Makefile	/^OFILES = $(C_OFILES) $(S_OFILES)$/;"	m
OFILES	build.macosx/Makefile	/^OFILES = $(C_OFILES) $(S_OFILES)$/;"	m
OPENFILE_H	filesys/openfile.h	21;"	d
OP_ADD	machine/mipssim.h	25;"	d
OP_ADDI	machine/mipssim.h	26;"	d
OP_ADDIU	machine/mipssim.h	27;"	d
OP_ADDU	machine/mipssim.h	28;"	d
OP_AND	machine/mipssim.h	29;"	d
OP_ANDI	machine/mipssim.h	30;"	d
OP_BEQ	machine/mipssim.h	31;"	d
OP_BGEZ	machine/mipssim.h	32;"	d
OP_BGEZAL	machine/mipssim.h	33;"	d
OP_BGTZ	machine/mipssim.h	34;"	d
OP_BLEZ	machine/mipssim.h	35;"	d
OP_BLTZ	machine/mipssim.h	36;"	d
OP_BLTZAL	machine/mipssim.h	37;"	d
OP_BNE	machine/mipssim.h	38;"	d
OP_DIV	machine/mipssim.h	40;"	d
OP_DIVU	machine/mipssim.h	41;"	d
OP_J	machine/mipssim.h	42;"	d
OP_JAL	machine/mipssim.h	43;"	d
OP_JALR	machine/mipssim.h	44;"	d
OP_JR	machine/mipssim.h	45;"	d
OP_LB	machine/mipssim.h	46;"	d
OP_LBU	machine/mipssim.h	47;"	d
OP_LH	machine/mipssim.h	48;"	d
OP_LHU	machine/mipssim.h	49;"	d
OP_LUI	machine/mipssim.h	50;"	d
OP_LW	machine/mipssim.h	51;"	d
OP_LWL	machine/mipssim.h	52;"	d
OP_LWR	machine/mipssim.h	53;"	d
OP_MFHI	machine/mipssim.h	55;"	d
OP_MFLO	machine/mipssim.h	56;"	d
OP_MTHI	machine/mipssim.h	58;"	d
OP_MTLO	machine/mipssim.h	59;"	d
OP_MULT	machine/mipssim.h	60;"	d
OP_MULTU	machine/mipssim.h	61;"	d
OP_NOR	machine/mipssim.h	62;"	d
OP_OR	machine/mipssim.h	63;"	d
OP_ORI	machine/mipssim.h	64;"	d
OP_RES	machine/mipssim.h	87;"	d
OP_RFE	machine/mipssim.h	65;"	d
OP_SB	machine/mipssim.h	66;"	d
OP_SH	machine/mipssim.h	67;"	d
OP_SLL	machine/mipssim.h	68;"	d
OP_SLLV	machine/mipssim.h	69;"	d
OP_SLT	machine/mipssim.h	70;"	d
OP_SLTI	machine/mipssim.h	71;"	d
OP_SLTIU	machine/mipssim.h	72;"	d
OP_SLTU	machine/mipssim.h	73;"	d
OP_SRA	machine/mipssim.h	74;"	d
OP_SRAV	machine/mipssim.h	75;"	d
OP_SRL	machine/mipssim.h	76;"	d
OP_SRLV	machine/mipssim.h	77;"	d
OP_SUB	machine/mipssim.h	78;"	d
OP_SUBU	machine/mipssim.h	79;"	d
OP_SW	machine/mipssim.h	80;"	d
OP_SWL	machine/mipssim.h	81;"	d
OP_SWR	machine/mipssim.h	82;"	d
OP_SYSCALL	machine/mipssim.h	85;"	d
OP_UNIMP	machine/mipssim.h	86;"	d
OP_XOR	machine/mipssim.h	83;"	d
OP_XORI	machine/mipssim.h	84;"	d
OSF_OR_AIX	lib/sysdep.cc	76;"	d	file:
OSF_OR_AIX	lib/sysdep.cc	79;"	d	file:
OneInstruction	machine/machine.h	/^    void OneInstruction(Instruction *instr); 	$/;"	p	class:Machine	access:private	signature:(Instruction *instr)
OneInstruction	machine/mipssim.cc	/^Machine::OneInstruction(Instruction *instr)$/;"	f	class:Machine	signature:(Instruction *instr)
OneTick	machine/interrupt.cc	/^Interrupt::OneTick()$/;"	f	class:Interrupt	signature:()
OneTick	machine/interrupt.h	/^    void OneTick();       	\/\/ Advance simulated time$/;"	p	class:Interrupt	access:public	signature:()
OpInfo	machine/mipssim.h	/^struct OpInfo {$/;"	s
OpInfo::format	machine/mipssim.h	/^    int format;		\/* Format type (IFMT or JFMT or RFMT) *\/$/;"	m	struct:OpInfo	access:public
OpInfo::opCode	machine/mipssim.h	/^    int opCode;		\/* Translated op code. *\/$/;"	m	struct:OpInfo	access:public
OpString	machine/mipssim.h	/^struct OpString {$/;"	s
OpString::args	machine/mipssim.h	/^    RegType args[3];$/;"	m	struct:OpString	access:public
OpString::format	machine/mipssim.h	/^    char *format;	\/\/ Printed version of instruction$/;"	m	struct:OpString	access:public
Open	filesys/filesys.cc	/^FileSystem::Open(char *name)$/;"	f	class:FileSystem	signature:(char *name)
Open	filesys/filesys.h	/^    OpenFile* Open(char *name) {$/;"	f	class:FileSystem	access:public	signature:(char *name)
Open	filesys/filesys.h	/^    OpenFile* Open(char *name); 	\/\/ Open a file (UNIX open)$/;"	p	class:FileSystem	access:public	signature:(char *name)
Open	test/start.S	/^Open:$/;"	l
Open	userprog/syscall.h	/^OpenFileId Open(char *name);$/;"	p	signature:(char *name)
OpenFile	filesys/openfile.cc	/^OpenFile::OpenFile(int sector)$/;"	f	class:OpenFile	signature:(int sector)
OpenFile	filesys/openfile.h	/^    OpenFile(int f) { file = f; currentOffset = 0; }	\/\/ open the file$/;"	f	class:OpenFile	access:public	signature:(int f)
OpenFile	filesys/openfile.h	/^    OpenFile(int sector);		\/\/ Open a file whose header is located$/;"	p	class:OpenFile	access:public	signature:(int sector)
OpenFile	filesys/openfile.h	/^class OpenFile {$/;"	c
OpenFile::Length	filesys/openfile.cc	/^OpenFile::Length() $/;"	f	class:OpenFile	signature:()
OpenFile::Length	filesys/openfile.h	/^    int Length() { Lseek(file, 0, 2); return Tell(file); }$/;"	f	class:OpenFile	access:public	signature:()
OpenFile::Length	filesys/openfile.h	/^    int Length(); 			\/\/ Return the number of bytes in the$/;"	p	class:OpenFile	access:public	signature:()
OpenFile::OpenFile	filesys/openfile.cc	/^OpenFile::OpenFile(int sector)$/;"	f	class:OpenFile	signature:(int sector)
OpenFile::OpenFile	filesys/openfile.h	/^    OpenFile(int f) { file = f; currentOffset = 0; }	\/\/ open the file$/;"	f	class:OpenFile	access:public	signature:(int f)
OpenFile::OpenFile	filesys/openfile.h	/^    OpenFile(int sector);		\/\/ Open a file whose header is located$/;"	p	class:OpenFile	access:public	signature:(int sector)
OpenFile::Read	filesys/openfile.cc	/^OpenFile::Read(char *into, int numBytes)$/;"	f	class:OpenFile	signature:(char *into, int numBytes)
OpenFile::Read	filesys/openfile.h	/^    int Read(char *into, int numBytes) {$/;"	f	class:OpenFile	access:public	signature:(char *into, int numBytes)
OpenFile::Read	filesys/openfile.h	/^    int Read(char *into, int numBytes); \/\/ Read\/write bytes from the file,$/;"	p	class:OpenFile	access:public	signature:(char *into, int numBytes)
OpenFile::ReadAt	filesys/openfile.cc	/^OpenFile::ReadAt(char *into, int numBytes, int position)$/;"	f	class:OpenFile	signature:(char *into, int numBytes, int position)
OpenFile::ReadAt	filesys/openfile.h	/^    int ReadAt(char *into, int numBytes, int position) { $/;"	f	class:OpenFile	access:public	signature:(char *into, int numBytes, int position)
OpenFile::ReadAt	filesys/openfile.h	/^    int ReadAt(char *into, int numBytes, int position);$/;"	p	class:OpenFile	access:public	signature:(char *into, int numBytes, int position)
OpenFile::Seek	filesys/openfile.cc	/^OpenFile::Seek(int position)$/;"	f	class:OpenFile	signature:(int position)
OpenFile::Seek	filesys/openfile.h	/^    void Seek(int position); 		\/\/ Set the position from which to $/;"	p	class:OpenFile	access:public	signature:(int position)
OpenFile::Write	filesys/openfile.cc	/^OpenFile::Write(char *into, int numBytes)$/;"	f	class:OpenFile	signature:(char *into, int numBytes)
OpenFile::Write	filesys/openfile.h	/^    int Write(char *from, int numBytes) {$/;"	f	class:OpenFile	access:public	signature:(char *from, int numBytes)
OpenFile::Write	filesys/openfile.h	/^    int Write(char *from, int numBytes);$/;"	p	class:OpenFile	access:public	signature:(char *from, int numBytes)
OpenFile::WriteAt	filesys/openfile.cc	/^OpenFile::WriteAt(char *from, int numBytes, int position)$/;"	f	class:OpenFile	signature:(char *from, int numBytes, int position)
OpenFile::WriteAt	filesys/openfile.h	/^    int WriteAt(char *from, int numBytes, int position) { $/;"	f	class:OpenFile	access:public	signature:(char *from, int numBytes, int position)
OpenFile::WriteAt	filesys/openfile.h	/^    int WriteAt(char *from, int numBytes, int position);$/;"	p	class:OpenFile	access:public	signature:(char *from, int numBytes, int position)
OpenFile::currentOffset	filesys/openfile.h	/^    int currentOffset;$/;"	m	class:OpenFile	access:private
OpenFile::file	filesys/openfile.h	/^    int file;$/;"	m	class:OpenFile	access:private
OpenFile::hdr	filesys/openfile.h	/^    FileHeader *hdr;			\/\/ Header for this file $/;"	m	class:OpenFile	access:private
OpenFile::seekPosition	filesys/openfile.h	/^    int seekPosition;			\/\/ Current position within the file$/;"	m	class:OpenFile	access:private
OpenFile::~OpenFile	filesys/openfile.cc	/^OpenFile::~OpenFile()$/;"	f	class:OpenFile	signature:()
OpenFile::~OpenFile	filesys/openfile.h	/^    ~OpenFile() { Close(file); }			\/\/ close the file$/;"	f	class:OpenFile	access:public	signature:()
OpenFile::~OpenFile	filesys/openfile.h	/^    ~OpenFile();			\/\/ Close the file$/;"	p	class:OpenFile	access:public	signature:()
OpenFileId	userprog/syscall.h	/^typedef int OpenFileId;	$/;"	t
OpenForReadWrite	lib/sysdep.cc	/^OpenForReadWrite(char *name, bool crashOnError)$/;"	f	signature:(char *name, bool crashOnError)
OpenForReadWrite	lib/sysdep.h	/^extern int OpenForReadWrite(char *name, bool crashOnError);$/;"	p	signature:(char *name, bool crashOnError)
OpenForWrite	lib/sysdep.cc	/^OpenForWrite(char *name)$/;"	f	signature:(char *name)
OpenForWrite	lib/sysdep.h	/^extern int OpenForWrite(char *name);$/;"	p	signature:(char *name)
OpenSocket	lib/sysdep.cc	/^OpenSocket()$/;"	f	signature:()
OpenSocket	lib/sysdep.h	/^extern int OpenSocket();$/;"	p	signature:()
OverflowException	machine/machine.h	/^		     OverflowException,     \/\/ Integer overflow in add or sub.$/;"	e	enum:ExceptionType
P	threads/synch.cc	/^Semaphore::P()$/;"	f	class:Semaphore	signature:()
P	threads/synch.h	/^    void P();	 	\/\/ these are the only operations on a semaphore$/;"	p	class:Semaphore	access:public	signature:()
P1	threads/switch.h	162;"	d
P2	threads/switch.h	163;"	d
P3	threads/switch.h	164;"	d
P4	threads/switch.h	165;"	d
PBITMAP_H	filesys/pbitmap.h	14;"	d
PC	threads/switch.h	115;"	d
PC	threads/switch.h	243;"	d
PC	threads/switch.h	39;"	d
PC	threads/switch.h	79;"	d
PCReg	machine/machine.h	69;"	d
PCState	threads/switch.h	123;"	d
PCState	threads/switch.h	145;"	d
PCState	threads/switch.h	214;"	d
PCState	threads/switch.h	259;"	d
PCState	threads/switch.h	56;"	d
PCState	threads/switch.h	87;"	d
PLabelToAddr	threads/thread.cc	/^PLabelToAddr(void *plabel)$/;"	f	file:	signature:(void *plabel)
POST_H	network/post.h	28;"	d
PROGRAM	build.cygwin/Makefile	/^PROGRAM = nachos$/;"	m
PROGRAM	build.linux/Makefile	/^PROGRAM = nachos$/;"	m
PROGRAM	build.macosx/Makefile	/^PROGRAM = nachos$/;"	m
PROGRAMS	test/Makefile	/^PROGRAMS = add add2 halt shell matmult sort segments$/;"	m
PROGRAMS	test/Makefile	/^PROGRAMS = unknownhost$/;"	m
PacketHeader	machine/network.h	/^class PacketHeader {$/;"	c
PacketHeader::from	machine/network.h	/^    NetworkAddress from;	\/\/ source machine ID$/;"	m	class:PacketHeader	access:public
PacketHeader::length	machine/network.h	/^    unsigned length;	 	\/\/ bytes of packet data, excluding the $/;"	m	class:PacketHeader	access:public
PacketHeader::to	machine/network.h	/^    NetworkAddress to;		\/\/ Destination machine ID$/;"	m	class:PacketHeader	access:public
PageFaultException	machine/machine.h	/^		     PageFaultException,    \/\/ No valid translation found$/;"	e	enum:ExceptionType
PageSize	machine/machine.h	/^const int PageSize = 128; 		\/\/ set the page size equal to$/;"	v
PendingCompare	machine/interrupt.cc	/^PendingCompare (PendingInterrupt *x, PendingInterrupt *y)$/;"	f	file:	signature:(PendingInterrupt *x, PendingInterrupt *y)
PendingInterrupt	machine/interrupt.cc	/^PendingInterrupt::PendingInterrupt(CallBackObj *callOnInt, $/;"	f	class:PendingInterrupt	signature:(CallBackObj *callOnInt, int time, IntType kind)
PendingInterrupt	machine/interrupt.h	/^    PendingInterrupt(CallBackObj *callOnInt, int time, IntType kind);$/;"	p	class:PendingInterrupt	access:public	signature:(CallBackObj *callOnInt, int time, IntType kind)
PendingInterrupt	machine/interrupt.h	/^class PendingInterrupt {$/;"	c
PendingInterrupt::PendingInterrupt	machine/interrupt.cc	/^PendingInterrupt::PendingInterrupt(CallBackObj *callOnInt, $/;"	f	class:PendingInterrupt	signature:(CallBackObj *callOnInt, int time, IntType kind)
PendingInterrupt::PendingInterrupt	machine/interrupt.h	/^    PendingInterrupt(CallBackObj *callOnInt, int time, IntType kind);$/;"	p	class:PendingInterrupt	access:public	signature:(CallBackObj *callOnInt, int time, IntType kind)
PendingInterrupt::callOnInterrupt	machine/interrupt.h	/^    CallBackObj *callOnInterrupt;\/\/ The object (in the hardware device$/;"	m	class:PendingInterrupt	access:public
PendingInterrupt::type	machine/interrupt.h	/^    IntType type;		\/\/ for debugging$/;"	m	class:PendingInterrupt	access:public
PendingInterrupt::when	machine/interrupt.h	/^    int when;			\/\/ When the interrupt is supposed to fire$/;"	m	class:PendingInterrupt	access:public
PersistentBitmap	filesys/pbitmap.cc	/^PersistentBitmap::PersistentBitmap(OpenFile *file, int numItems):Bitmap(numItems) $/;"	f	class:PersistentBitmap	signature:(OpenFile *file, int numItems)
PersistentBitmap	filesys/pbitmap.cc	/^PersistentBitmap::PersistentBitmap(int numItems):Bitmap(numItems) $/;"	f	class:PersistentBitmap	signature:(int numItems)
PersistentBitmap	filesys/pbitmap.h	/^    PersistentBitmap(OpenFile *file,int numItems); \/\/initialize bitmap from disk $/;"	p	class:PersistentBitmap	access:public	signature:(OpenFile *file,int numItems)
PersistentBitmap	filesys/pbitmap.h	/^    PersistentBitmap(int numItems); \/\/ or don't...$/;"	p	class:PersistentBitmap	access:public	signature:(int numItems)
PersistentBitmap	filesys/pbitmap.h	/^class PersistentBitmap : public Bitmap {$/;"	c	inherits:Bitmap
PersistentBitmap::FetchFrom	filesys/pbitmap.cc	/^PersistentBitmap::FetchFrom(OpenFile *file) $/;"	f	class:PersistentBitmap	signature:(OpenFile *file)
PersistentBitmap::FetchFrom	filesys/pbitmap.h	/^    void FetchFrom(OpenFile *file);     \/\/ read bitmap from the disk$/;"	p	class:PersistentBitmap	access:public	signature:(OpenFile *file)
PersistentBitmap::PersistentBitmap	filesys/pbitmap.cc	/^PersistentBitmap::PersistentBitmap(OpenFile *file, int numItems):Bitmap(numItems) $/;"	f	class:PersistentBitmap	signature:(OpenFile *file, int numItems)
PersistentBitmap::PersistentBitmap	filesys/pbitmap.cc	/^PersistentBitmap::PersistentBitmap(int numItems):Bitmap(numItems) $/;"	f	class:PersistentBitmap	signature:(int numItems)
PersistentBitmap::PersistentBitmap	filesys/pbitmap.h	/^    PersistentBitmap(OpenFile *file,int numItems); \/\/initialize bitmap from disk $/;"	p	class:PersistentBitmap	access:public	signature:(OpenFile *file,int numItems)
PersistentBitmap::PersistentBitmap	filesys/pbitmap.h	/^    PersistentBitmap(int numItems); \/\/ or don't...$/;"	p	class:PersistentBitmap	access:public	signature:(int numItems)
PersistentBitmap::WriteBack	filesys/pbitmap.cc	/^PersistentBitmap::WriteBack(OpenFile *file)$/;"	f	class:PersistentBitmap	signature:(OpenFile *file)
PersistentBitmap::WriteBack	filesys/pbitmap.h	/^    void WriteBack(OpenFile *file); 	\/\/ write bitmap contents to disk $/;"	p	class:PersistentBitmap	access:public	signature:(OpenFile *file)
PersistentBitmap::~PersistentBitmap	filesys/pbitmap.cc	/^PersistentBitmap::~PersistentBitmap()$/;"	f	class:PersistentBitmap	signature:()
PersistentBitmap::~PersistentBitmap	filesys/pbitmap.h	/^    ~PersistentBitmap(); 			\/\/ deallocate bitmap$/;"	p	class:PersistentBitmap	access:public	signature:()
PollFile	lib/sysdep.cc	/^PollFile(int fd)$/;"	f	signature:(int fd)
PollFile	lib/sysdep.h	/^extern bool PollFile(int fd);$/;"	p	signature:(int fd)
PollSocket	lib/sysdep.cc	/^PollSocket(int sockID)$/;"	f	signature:(int sockID)
PollSocket	lib/sysdep.h	/^extern bool PollSocket(int sockID);$/;"	p	signature:(int sockID)
PostOfficeInput	network/post.cc	/^PostOfficeInput::PostOfficeInput(int nBoxes)$/;"	f	class:PostOfficeInput	signature:(int nBoxes)
PostOfficeInput	network/post.h	/^    PostOfficeInput(int nBoxes); \/\/ Allocate and initialize Post Office$/;"	p	class:PostOfficeInput	access:public	signature:(int nBoxes)
PostOfficeInput	network/post.h	/^class PostOfficeInput : public CallBackObj {$/;"	c	inherits:CallBackObj
PostOfficeInput::CallBack	network/post.cc	/^PostOfficeInput::CallBack()$/;"	f	class:PostOfficeInput	signature:()
PostOfficeInput::CallBack	network/post.h	/^    void CallBack();		\/\/ Called when incoming packet has arrived $/;"	p	class:PostOfficeInput	access:public	signature:()
PostOfficeInput::PostOfficeInput	network/post.cc	/^PostOfficeInput::PostOfficeInput(int nBoxes)$/;"	f	class:PostOfficeInput	signature:(int nBoxes)
PostOfficeInput::PostOfficeInput	network/post.h	/^    PostOfficeInput(int nBoxes); \/\/ Allocate and initialize Post Office$/;"	p	class:PostOfficeInput	access:public	signature:(int nBoxes)
PostOfficeInput::PostalDelivery	network/post.cc	/^PostOfficeInput::PostalDelivery(void* data)$/;"	f	class:PostOfficeInput	signature:(void* data)
PostOfficeInput::PostalDelivery	network/post.h	/^    static void PostalDelivery(void* data);$/;"	p	class:PostOfficeInput	access:public	signature:(void* data)
PostOfficeInput::Receive	network/post.cc	/^PostOfficeInput::Receive(int box, PacketHeader *pktHdr, $/;"	f	class:PostOfficeInput	signature:(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char* data)
PostOfficeInput::Receive	network/post.h	/^    void Receive(int box, PacketHeader *pktHdr, $/;"	p	class:PostOfficeInput	access:public	signature:(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
PostOfficeInput::boxes	network/post.h	/^    MailBox *boxes;		\/\/ Table of mail boxes to hold incoming mail$/;"	m	class:PostOfficeInput	access:private
PostOfficeInput::messageAvailable	network/post.h	/^    Semaphore *messageAvailable;\/\/ V'ed when message has arrived from network$/;"	m	class:PostOfficeInput	access:private
PostOfficeInput::network	network/post.h	/^    NetworkInput *network;	\/\/ Physical network connection$/;"	m	class:PostOfficeInput	access:private
PostOfficeInput::numBoxes	network/post.h	/^    int numBoxes;		\/\/ Number of mail boxes$/;"	m	class:PostOfficeInput	access:private
PostOfficeInput::~PostOfficeInput	network/post.cc	/^PostOfficeInput::~PostOfficeInput()$/;"	f	class:PostOfficeInput	signature:()
PostOfficeInput::~PostOfficeInput	network/post.h	/^    ~PostOfficeInput();		\/\/ De-allocate Post Office data$/;"	p	class:PostOfficeInput	access:public	signature:()
PostOfficeOutput	network/post.cc	/^PostOfficeOutput::PostOfficeOutput(double reliability)$/;"	f	class:PostOfficeOutput	signature:(double reliability)
PostOfficeOutput	network/post.h	/^    PostOfficeOutput(double reliability);$/;"	p	class:PostOfficeOutput	access:public	signature:(double reliability)
PostOfficeOutput	network/post.h	/^class PostOfficeOutput : public CallBackObj {$/;"	c	inherits:CallBackObj
PostOfficeOutput::CallBack	network/post.cc	/^PostOfficeOutput::CallBack()$/;"	f	class:PostOfficeOutput	signature:()
PostOfficeOutput::CallBack	network/post.h	/^    void CallBack();		\/\/ Called when outgoing packet has been $/;"	p	class:PostOfficeOutput	access:public	signature:()
PostOfficeOutput::PostOfficeOutput	network/post.cc	/^PostOfficeOutput::PostOfficeOutput(double reliability)$/;"	f	class:PostOfficeOutput	signature:(double reliability)
PostOfficeOutput::PostOfficeOutput	network/post.h	/^    PostOfficeOutput(double reliability);$/;"	p	class:PostOfficeOutput	access:public	signature:(double reliability)
PostOfficeOutput::Send	network/post.cc	/^PostOfficeOutput::Send(PacketHeader pktHdr, MailHeader mailHdr, char* data)$/;"	f	class:PostOfficeOutput	signature:(PacketHeader pktHdr, MailHeader mailHdr, char* data)
PostOfficeOutput::Send	network/post.h	/^    void Send(PacketHeader pktHdr, MailHeader mailHdr, char *data);$/;"	p	class:PostOfficeOutput	access:public	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
PostOfficeOutput::messageSent	network/post.h	/^    Semaphore *messageSent;	\/\/ V'ed when next message can be sent to network$/;"	m	class:PostOfficeOutput	access:private
PostOfficeOutput::network	network/post.h	/^    NetworkOutput *network;	\/\/ Physical network connection$/;"	m	class:PostOfficeOutput	access:private
PostOfficeOutput::sendLock	network/post.h	/^    Lock *sendLock;		\/\/ Only one outgoing message at a time$/;"	m	class:PostOfficeOutput	access:private
PostOfficeOutput::~PostOfficeOutput	network/post.cc	/^PostOfficeOutput::~PostOfficeOutput()$/;"	f	class:PostOfficeOutput	signature:()
PostOfficeOutput::~PostOfficeOutput	network/post.h	/^    ~PostOfficeOutput();	\/\/ De-allocate Post Office data$/;"	p	class:PostOfficeOutput	access:public	signature:()
PostalDelivery	network/post.cc	/^PostOfficeInput::PostalDelivery(void* data)$/;"	f	class:PostOfficeInput	signature:(void* data)
PostalDelivery	network/post.h	/^    static void PostalDelivery(void* data);$/;"	p	class:PostOfficeInput	access:public	signature:(void* data)
Prepend	lib/list.cc	/^List<T>::Prepend(T item)$/;"	f	class:List	signature:(T item)
Prepend	lib/list.h	/^    virtual void Prepend(T item);\/\/ Put item at the beginning of the list$/;"	p	class:List	access:public	signature:(T item)
Prepend	lib/list.h	/^    void Prepend(T item) { Insert(item); }  \/\/ *pre*pending has no meaning $/;"	f	class:SortedList	access:private	signature:(T item)
PrevPCReg	machine/machine.h	71;"	d
Print	filesys/directory.cc	/^Directory::Print()$/;"	f	class:Directory	signature:()
Print	filesys/directory.h	/^    void Print();			\/\/ Verbose print of the contents$/;"	p	class:Directory	access:public	signature:()
Print	filesys/filehdr.cc	/^FileHeader::Print()$/;"	f	class:FileHeader	signature:()
Print	filesys/filehdr.h	/^    void Print();			\/\/ Print the contents of the file.$/;"	p	class:FileHeader	access:public	signature:()
Print	filesys/filesys.cc	/^FileSystem::Print()$/;"	f	class:FileSystem	signature:()
Print	filesys/filesys.h	/^    void Print();			\/\/ List all the files and their contents$/;"	p	class:FileSystem	access:public	signature:()
Print	lib/bitmap.cc	/^Bitmap::Print() const$/;"	f	class:Bitmap	signature:() const
Print	lib/bitmap.h	/^    void Print() const;		\/\/ Print contents of bitmap$/;"	p	class:Bitmap	access:public	signature:() const
Print	machine/stats.cc	/^Statistics::Print()$/;"	f	class:Statistics	signature:()
Print	machine/stats.h	/^    void Print();		\/\/ print collected statistics$/;"	p	class:Statistics	access:public	signature:()
Print	threads/main.cc	/^Print(char *name)$/;"	f	signature:(char *name)
Print	threads/scheduler.cc	/^Scheduler::Print()$/;"	f	class:Scheduler	signature:()
Print	threads/scheduler.h	/^    void Print();		\/\/ Print contents of ready list$/;"	p	class:Scheduler	access:public	signature:()
Print	threads/thread.h	/^    void Print() { cout << name; }$/;"	f	class:Thread	access:public	signature:()
PrintHeader	network/post.cc	/^PrintHeader(PacketHeader pktHdr, MailHeader mailHdr)$/;"	f	file:	signature:(PacketHeader pktHdr, MailHeader mailHdr)
PrintPending	machine/interrupt.cc	/^PrintPending (PendingInterrupt *pending)$/;"	f	file:	signature:(PendingInterrupt *pending)
PrintSector	machine/disk.cc	/^PrintSector (bool writing, int sector, char *data)$/;"	f	file:	signature:(bool writing, int sector, char *data)
Put	network/post.cc	/^MailBox::Put(PacketHeader pktHdr, MailHeader mailHdr, char *data)$/;"	f	class:MailBox	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
Put	network/post.h	/^    void Put(PacketHeader pktHdr, MailHeader mailHdr, char *data);$/;"	p	class:MailBox	access:public	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
PutChar	machine/console.cc	/^ConsoleOutput::PutChar(char ch)$/;"	f	class:ConsoleOutput	signature:(char ch)
PutChar	machine/console.h	/^    void PutChar(char ch);	\/\/ Write "ch" to the console display, $/;"	p	class:ConsoleOutput	access:public	signature:(char ch)
PutChar	userprog/synchconsole.cc	/^SynchConsoleOutput::PutChar(char ch)$/;"	f	class:SynchConsoleOutput	signature:(char ch)
PutChar	userprog/synchconsole.h	/^    void PutChar(char ch);	\/\/ Write a character, waiting if necessary$/;"	p	class:SynchConsoleOutput	access:public	signature:(char ch)
R31	machine/mipssim.h	97;"	d
RD	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
READY	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
RFMT	machine/mipssim.h	110;"	d
RM	build.cygwin/Makefile	/^RM = rm$/;"	m
RM	build.linux/Makefile	/^RM = \/bin\/rm$/;"	m
RM	build.macosx/Makefile	/^RM = \/bin\/rm$/;"	m
RS	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
RT	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	e	enum:RegType
RUNNING	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
RaiseException	machine/machine.cc	/^Machine::RaiseException(ExceptionType which, int badVAddr)$/;"	f	class:Machine	signature:(ExceptionType which, int badVAddr)
RaiseException	machine/machine.h	/^    void RaiseException(ExceptionType which, int badVAddr);$/;"	p	class:Machine	access:private	signature:(ExceptionType which, int badVAddr)
RandomInit	lib/sysdep.cc	/^RandomInit(unsigned seed)$/;"	f	signature:(unsigned seed)
RandomInit	lib/sysdep.h	/^extern void RandomInit(unsigned seed);$/;"	p	signature:(unsigned seed)
RandomNumber	lib/sysdep.cc	/^RandomNumber()$/;"	f	signature:()
RandomNumber	lib/sysdep.h	/^extern unsigned int RandomNumber();$/;"	p	signature:()
ReHash	lib/hash.cc	/^HashTable<Key,T>::ReHash()$/;"	f	class:HashTable	signature:()
ReHash	lib/hash.h	/^    void ReHash();		\/\/ expand the hash table$/;"	p	class:HashTable	access:private	signature:()
Read	filesys/openfile.cc	/^OpenFile::Read(char *into, int numBytes)$/;"	f	class:OpenFile	signature:(char *into, int numBytes)
Read	filesys/openfile.h	/^    int Read(char *into, int numBytes) {$/;"	f	class:OpenFile	access:public	signature:(char *into, int numBytes)
Read	filesys/openfile.h	/^    int Read(char *into, int numBytes); \/\/ Read\/write bytes from the file,$/;"	p	class:OpenFile	access:public	signature:(char *into, int numBytes)
Read	lib/sysdep.cc	/^Read(int fd, char *buffer, int nBytes)$/;"	f	signature:(int fd, char *buffer, int nBytes)
Read	lib/sysdep.h	/^extern void Read(int fd, char *buffer, int nBytes);$/;"	p	signature:(int fd, char *buffer, int nBytes)
Read	test/start.S	/^Read:$/;"	l
Read	userprog/syscall.h	/^int Read(char *buffer, int size, OpenFileId id);$/;"	p	signature:(char *buffer, int size, OpenFileId id)
ReadAt	filesys/openfile.cc	/^OpenFile::ReadAt(char *into, int numBytes, int position)$/;"	f	class:OpenFile	signature:(char *into, int numBytes, int position)
ReadAt	filesys/openfile.h	/^    int ReadAt(char *into, int numBytes, int position) { $/;"	f	class:OpenFile	access:public	signature:(char *into, int numBytes, int position)
ReadAt	filesys/openfile.h	/^    int ReadAt(char *into, int numBytes, int position);$/;"	p	class:OpenFile	access:public	signature:(char *into, int numBytes, int position)
ReadFromSocket	lib/sysdep.cc	/^ReadFromSocket(int sockID, char *buffer, int packetSize)$/;"	f	signature:(int sockID, char *buffer, int packetSize)
ReadFromSocket	lib/sysdep.h	/^extern void ReadFromSocket(int sockID, char *buffer, int packetSize);$/;"	p	signature:(int sockID, char *buffer, int packetSize)
ReadMem	machine/machine.h	/^    bool ReadMem(int addr, int size, int* value);$/;"	p	class:Machine	access:public	signature:(int addr, int size, int* value)
ReadMem	machine/translate.cc	/^Machine::ReadMem(int addr, int size, int *value)$/;"	f	class:Machine	signature:(int addr, int size, int *value)
ReadOnlyException	machine/machine.h	/^		     ReadOnlyException,     \/\/ Write attempted to page marked $/;"	e	enum:ExceptionType
ReadPartial	lib/sysdep.cc	/^ReadPartial(int fd, char *buffer, int nBytes)$/;"	f	signature:(int fd, char *buffer, int nBytes)
ReadPartial	lib/sysdep.h	/^extern int ReadPartial(int fd, char *buffer, int nBytes);$/;"	p	signature:(int fd, char *buffer, int nBytes)
ReadRegister	machine/machine.cc	/^Machine::ReadRegister(int num)$/;"	f	class:Machine	signature:(int num)
ReadRegister	machine/machine.h	/^    int ReadRegister(int num);	\/\/ read the contents of a CPU register$/;"	p	class:Machine	access:public	signature:(int num)
ReadRequest	machine/disk.cc	/^Disk::ReadRequest(int sectorNumber, char* data)$/;"	f	class:Disk	signature:(int sectorNumber, char* data)
ReadRequest	machine/disk.h	/^    void ReadRequest(int sectorNumber, char* data);$/;"	p	class:Disk	access:public	signature:(int sectorNumber, char* data)
ReadSector	filesys/synchdisk.cc	/^SynchDisk::ReadSector(int sectorNumber, char* data)$/;"	f	class:SynchDisk	signature:(int sectorNumber, char* data)
ReadSector	filesys/synchdisk.h	/^    void ReadSector(int sectorNumber, char* data);$/;"	p	class:SynchDisk	access:public	signature:(int sectorNumber, char* data)
ReadyToRun	threads/scheduler.cc	/^Scheduler::ReadyToRun (Thread *thread)$/;"	f	class:Scheduler	signature:(Thread *thread)
ReadyToRun	threads/scheduler.h	/^    void ReadyToRun(Thread* thread);	$/;"	p	class:Scheduler	access:public	signature:(Thread* thread)
Receive	machine/network.cc	/^NetworkInput::Receive(char* data)$/;"	f	class:NetworkInput	signature:(char* data)
Receive	machine/network.h	/^    PacketHeader Receive(char* data);$/;"	p	class:NetworkInput	access:public	signature:(char* data)
Receive	network/post.cc	/^PostOfficeInput::Receive(int box, PacketHeader *pktHdr, $/;"	f	class:PostOfficeInput	signature:(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char* data)
Receive	network/post.h	/^    void Receive(int box, PacketHeader *pktHdr, $/;"	p	class:PostOfficeInput	access:public	signature:(int box, PacketHeader *pktHdr, MailHeader *mailHdr, char *data)
RegType	machine/mipssim.h	/^enum RegType { NONE, RS, RT, RD, EXTRA }; $/;"	g
Release	threads/synch.cc	/^void Lock::Release()$/;"	f	class:Lock	signature:()
Release	threads/synch.h	/^    void Release(); 		\/\/ they are both *atomic*$/;"	p	class:Lock	access:public	signature:()
Remove	filesys/directory.cc	/^Directory::Remove(char *name)$/;"	f	class:Directory	signature:(char *name)
Remove	filesys/directory.h	/^    bool Remove(char *name);		\/\/ Remove a file from the directory$/;"	p	class:Directory	access:public	signature:(char *name)
Remove	filesys/filesys.cc	/^FileSystem::Remove(char *name)$/;"	f	class:FileSystem	signature:(char *name)
Remove	filesys/filesys.h	/^    bool Remove(char *name) { return Unlink(name) == 0; }$/;"	f	class:FileSystem	access:public	signature:(char *name)
Remove	filesys/filesys.h	/^    bool Remove(char *name);  		\/\/ Delete a file (UNIX unlink)$/;"	p	class:FileSystem	access:public	signature:(char *name)
Remove	lib/hash.cc	/^HashTable<Key,T>::Remove(Key key)$/;"	f	class:HashTable	signature:(Key key)
Remove	lib/hash.h	/^    T Remove(Key key);		\/\/ Remove item from hash table.$/;"	p	class:HashTable	access:public	signature:(Key key)
Remove	lib/list.cc	/^List<T>::Remove(T item)$/;"	f	class:List	signature:(T item)
Remove	lib/list.h	/^    void Remove(T item); 	\/\/ Remove specific item from list$/;"	p	class:List	access:public	signature:(T item)
Remove	test/start.S	/^Remove:$/;"	l
Remove	userprog/syscall.h	/^int Remove(char *name);$/;"	p	signature:(char *name)
RemoveFront	lib/list.cc	/^List<T>::RemoveFront()$/;"	f	class:List	signature:()
RemoveFront	lib/list.h	/^    T RemoveFront(); 		\/\/ Take item off the front of the list$/;"	p	class:List	access:public	signature:()
RemoveFront	threads/synchlist.cc	/^SynchList<T>::RemoveFront()$/;"	f	class:SynchList	signature:()
RemoveFront	threads/synchlist.h	/^    T RemoveFront();		\/\/ remove the first item from the front of$/;"	p	class:SynchList	access:public	signature:()
ResizeRatio	lib/hash.cc	/^const int ResizeRatio = 3;	\/\/ when do we grow the hash table?$/;"	v
RestoreState	userprog/addrspace.cc	/^void AddrSpace::RestoreState() $/;"	f	class:AddrSpace	signature:()
RestoreState	userprog/addrspace.h	/^    void RestoreState();		\/\/ info on a context switch $/;"	p	class:AddrSpace	access:public	signature:()
RestoreUserState	threads/thread.cc	/^Thread::RestoreUserState()$/;"	f	class:Thread	signature:()
RestoreUserState	threads/thread.h	/^    void RestoreUserState();		\/\/ restore user-level register state$/;"	p	class:Thread	access:public	signature:()
RetAddrReg	machine/machine.h	65;"	d
RotationTime	machine/stats.h	/^const int RotationTime = 500; 	\/\/ time disk takes to rotate one sector$/;"	v
Run	machine/machine.h	/^    void Run();	 		\/\/ Run a user program$/;"	p	class:Machine	access:public	signature:()
Run	machine/mipssim.cc	/^Machine::Run()$/;"	f	class:Machine	signature:()
Run	threads/scheduler.cc	/^Scheduler::Run (Thread *nextThread, bool finishing)$/;"	f	class:Scheduler	signature:(Thread *nextThread, bool finishing)
Run	threads/scheduler.h	/^    void Run(Thread* nextThread, bool finishing);$/;"	p	class:Scheduler	access:public	signature:(Thread* nextThread, bool finishing)
S0	threads/switch.h	235;"	d
S0	threads/switch.h	30;"	d
S0	threads/switch.h	99;"	d
S1	threads/switch.h	100;"	d
S1	threads/switch.h	236;"	d
S1	threads/switch.h	31;"	d
S10	threads/switch.h	109;"	d
S11	threads/switch.h	110;"	d
S12	threads/switch.h	111;"	d
S13	threads/switch.h	112;"	d
S14	threads/switch.h	113;"	d
S15	threads/switch.h	114;"	d
S2	threads/switch.h	101;"	d
S2	threads/switch.h	237;"	d
S2	threads/switch.h	32;"	d
S3	threads/switch.h	102;"	d
S3	threads/switch.h	238;"	d
S3	threads/switch.h	33;"	d
S4	threads/switch.h	103;"	d
S4	threads/switch.h	239;"	d
S4	threads/switch.h	34;"	d
S5	threads/switch.h	104;"	d
S5	threads/switch.h	240;"	d
S5	threads/switch.h	35;"	d
S6	threads/switch.h	105;"	d
S6	threads/switch.h	241;"	d
S6	threads/switch.h	36;"	d
S7	threads/switch.h	106;"	d
S7	threads/switch.h	37;"	d
S8	threads/switch.h	107;"	d
S9	threads/switch.h	108;"	d
SCHEDULER_H	threads/scheduler.h	10;"	d
SC_Add	userprog/syscall.h	38;"	d
SC_Close	userprog/syscall.h	31;"	d
SC_Create	userprog/syscall.h	25;"	d
SC_Exec	userprog/syscall.h	23;"	d
SC_ExecV	userprog/syscall.h	34;"	d
SC_Exit	userprog/syscall.h	22;"	d
SC_Halt	userprog/syscall.h	21;"	d
SC_Join	userprog/syscall.h	24;"	d
SC_Open	userprog/syscall.h	27;"	d
SC_Read	userprog/syscall.h	28;"	d
SC_Remove	userprog/syscall.h	26;"	d
SC_Seek	userprog/syscall.h	30;"	d
SC_ThreadExit	userprog/syscall.h	35;"	d
SC_ThreadFork	userprog/syscall.h	32;"	d
SC_ThreadJoin	userprog/syscall.h	36;"	d
SC_ThreadYield	userprog/syscall.h	33;"	d
SC_Write	userprog/syscall.h	29;"	d
SIGN_BIT	machine/mipssim.h	96;"	d
SIZE	test/sort.c	23;"	d	file:
SP	threads/switch.h	161;"	d
SP	threads/switch.h	234;"	d
SP	threads/switch.h	29;"	d
SP	threads/switch.h	98;"	d
SPECIAL	machine/mipssim.h	105;"	d
STACK_FENCEPOST	threads/thread.cc	/^const int STACK_FENCEPOST = 0xdedbeef;$/;"	v
STATS_H	machine/stats.h	12;"	d
SWITCH	threads/switch.S	/^SWITCH$/;"	l
SWITCH	threads/switch.S	/^SWITCH:$/;"	l
SWITCH	threads/thread.h	/^void SWITCH(Thread *oldThread, Thread *newThread);$/;"	p	signature:(Thread *oldThread, Thread *newThread)
SWITCH_H	threads/switch.h	19;"	d
SYNCHCONSOLE_H	userprog/synchconsole.h	12;"	d
SYNCHDISK_H	filesys/synchdisk.h	12;"	d
SYNCHLIST_H	threads/synchlist.h	11;"	d
SYNCH_H	threads/synch.h	18;"	d
SYSCALLS_H	userprog/syscall.h	14;"	d
SYSDEP_H	lib/sysdep.h	12;"	d
S_OFILES	build.cygwin/Makefile	/^S_OFILES = switch.o$/;"	m
S_OFILES	build.linux/Makefile	/^S_OFILES = switch.o$/;"	m
S_OFILES	build.macosx/Makefile	/^S_OFILES = switch.o$/;"	m
SanityCheck	lib/hash.cc	/^HashTable<Key,T>::SanityCheck() const$/;"	f	class:HashTable	signature:() const
SanityCheck	lib/hash.h	/^    void SanityCheck() const;\/\/ is this still a legal hash table?$/;"	p	class:HashTable	access:public	signature:() const
SanityCheck	lib/list.cc	/^List<T>::SanityCheck() const$/;"	f	class:List	signature:() const
SanityCheck	lib/list.cc	/^SortedList<T>::SanityCheck() const$/;"	f	class:SortedList	signature:() const
SanityCheck	lib/list.h	/^    virtual void SanityCheck() const;	$/;"	p	class:List	access:public	signature:() const
SanityCheck	lib/list.h	/^    void SanityCheck() const;	\/\/ has this list been corrupted?$/;"	p	class:SortedList	access:public	signature:() const
SaveState	userprog/addrspace.cc	/^void AddrSpace::SaveState() $/;"	f	class:AddrSpace	signature:()
SaveState	userprog/addrspace.h	/^    void SaveState();			\/\/ Save\/restore address space-specific$/;"	p	class:AddrSpace	access:public	signature:()
SaveUserState	threads/thread.cc	/^Thread::SaveUserState()$/;"	f	class:Thread	signature:()
SaveUserState	threads/thread.h	/^    void SaveUserState();		\/\/ save user-level register state$/;"	p	class:Thread	access:public	signature:()
Schedule	machine/interrupt.cc	/^Interrupt::Schedule(CallBackObj *toCall, int fromNow, IntType type)$/;"	f	class:Interrupt	signature:(CallBackObj *toCall, int fromNow, IntType type)
Schedule	machine/interrupt.h	/^    void Schedule(CallBackObj *callTo, int when, IntType type);$/;"	p	class:Interrupt	access:public	signature:(CallBackObj *callTo, int when, IntType type)
Scheduler	threads/scheduler.cc	/^Scheduler::Scheduler()$/;"	f	class:Scheduler	signature:()
Scheduler	threads/scheduler.h	/^    Scheduler();		\/\/ Initialize list of ready threads $/;"	p	class:Scheduler	access:public	signature:()
Scheduler	threads/scheduler.h	/^class Scheduler {$/;"	c
Scheduler::CheckToBeDestroyed	threads/scheduler.cc	/^Scheduler::CheckToBeDestroyed()$/;"	f	class:Scheduler	signature:()
Scheduler::CheckToBeDestroyed	threads/scheduler.h	/^    void CheckToBeDestroyed();\/\/ Check if thread that had been$/;"	p	class:Scheduler	access:public	signature:()
Scheduler::FindNextToRun	threads/scheduler.cc	/^Scheduler::FindNextToRun ()$/;"	f	class:Scheduler	signature:()
Scheduler::FindNextToRun	threads/scheduler.h	/^    Thread* FindNextToRun();	\/\/ Dequeue first thread on the ready $/;"	p	class:Scheduler	access:public	signature:()
Scheduler::Print	threads/scheduler.cc	/^Scheduler::Print()$/;"	f	class:Scheduler	signature:()
Scheduler::Print	threads/scheduler.h	/^    void Print();		\/\/ Print contents of ready list$/;"	p	class:Scheduler	access:public	signature:()
Scheduler::ReadyToRun	threads/scheduler.cc	/^Scheduler::ReadyToRun (Thread *thread)$/;"	f	class:Scheduler	signature:(Thread *thread)
Scheduler::ReadyToRun	threads/scheduler.h	/^    void ReadyToRun(Thread* thread);	$/;"	p	class:Scheduler	access:public	signature:(Thread* thread)
Scheduler::Run	threads/scheduler.cc	/^Scheduler::Run (Thread *nextThread, bool finishing)$/;"	f	class:Scheduler	signature:(Thread *nextThread, bool finishing)
Scheduler::Run	threads/scheduler.h	/^    void Run(Thread* nextThread, bool finishing);$/;"	p	class:Scheduler	access:public	signature:(Thread* nextThread, bool finishing)
Scheduler::Scheduler	threads/scheduler.cc	/^Scheduler::Scheduler()$/;"	f	class:Scheduler	signature:()
Scheduler::Scheduler	threads/scheduler.h	/^    Scheduler();		\/\/ Initialize list of ready threads $/;"	p	class:Scheduler	access:public	signature:()
Scheduler::readyList	threads/scheduler.h	/^    List<Thread *> *readyList;  \/\/ queue of threads that are ready to run,$/;"	m	class:Scheduler	access:private
Scheduler::toBeDestroyed	threads/scheduler.h	/^    Thread *toBeDestroyed;	\/\/ finishing thread to be destroyed$/;"	m	class:Scheduler	access:private
Scheduler::~Scheduler	threads/scheduler.cc	/^Scheduler::~Scheduler()$/;"	f	class:Scheduler	signature:()
Scheduler::~Scheduler	threads/scheduler.h	/^    ~Scheduler();		\/\/ De-allocate ready list$/;"	p	class:Scheduler	access:public	signature:()
SectorSize	machine/disk.h	/^const int SectorSize = 128;		\/\/ number of bytes per disk sector$/;"	v
SectorsPerTrack	machine/disk.h	/^const int SectorsPerTrack  = 32;	\/\/ number of sectors per disk track $/;"	v
Seek	filesys/openfile.cc	/^OpenFile::Seek(int position)$/;"	f	class:OpenFile	signature:(int position)
Seek	filesys/openfile.h	/^    void Seek(int position); 		\/\/ Set the position from which to $/;"	p	class:OpenFile	access:public	signature:(int position)
Seek	test/start.S	/^Seek:$/;"	l
Seek	userprog/syscall.h	/^int Seek(int position, OpenFileId id);$/;"	p	signature:(int position, OpenFileId id)
SeekTime	machine/stats.h	/^const int SeekTime =	 500;  	\/\/ time disk takes to seek past one track$/;"	v
Segment	userprog/noff.h	/^} Segment;$/;"	t	typeref:struct:segment
SelfTest	lib/bitmap.cc	/^Bitmap::SelfTest() $/;"	f	class:Bitmap	signature:()
SelfTest	lib/bitmap.h	/^    void SelfTest();		\/\/ Test whether bitmap is working$/;"	p	class:Bitmap	access:public	signature:()
SelfTest	lib/hash.cc	/^HashTable<Key,T>::SelfTest(T *p, int numEntries)$/;"	f	class:HashTable	signature:(T *p, int numEntries)
SelfTest	lib/hash.h	/^    void SelfTest(T *p, int numItems);	$/;"	p	class:HashTable	access:public	signature:(T *p, int numItems)
SelfTest	lib/list.cc	/^List<T>::SelfTest(T *p, int numEntries)$/;"	f	class:List	signature:(T *p, int numEntries)
SelfTest	lib/list.cc	/^SortedList<T>::SelfTest(T *p, int numEntries)$/;"	f	class:SortedList	signature:(T *p, int numEntries)
SelfTest	lib/list.h	/^    void SelfTest(T *p, int numEntries);$/;"	p	class:List	access:public	signature:(T *p, int numEntries)
SelfTest	lib/list.h	/^    void SelfTest(T *p, int numEntries);$/;"	p	class:SortedList	access:public	signature:(T *p, int numEntries)
SelfTest	threads/synch.cc	/^Semaphore::SelfTest()$/;"	f	class:Semaphore	signature:()
SelfTest	threads/synch.h	/^    void SelfTest();	\/\/ test routine for semaphore implementation$/;"	p	class:Semaphore	access:public	signature:()
SelfTest	threads/synchlist.cc	/^SynchList<T>::SelfTest(T val)$/;"	f	class:SynchList	signature:(T val)
SelfTest	threads/synchlist.h	/^    void SelfTest(T value);	\/\/ test the SynchList implementation$/;"	p	class:SynchList	access:public	signature:(T value)
SelfTest	threads/thread.cc	/^Thread::SelfTest()$/;"	f	class:Thread	signature:()
SelfTest	threads/thread.h	/^    void SelfTest();		\/\/ test whether thread impl is working$/;"	p	class:Thread	access:public	signature:()
SelfTestHelper	threads/synch.cc	/^SelfTestHelper (Semaphore *pong) $/;"	f	file:	signature:(Semaphore *pong)
SelfTestHelper	threads/synchlist.cc	/^SynchList<T>::SelfTestHelper (void* data) $/;"	f	class:SynchList	signature:(void* data)
SelfTestHelper	threads/synchlist.h	/^    static void SelfTestHelper(void* data);$/;"	p	class:SynchList	access:private	signature:(void* data)
Semaphore	threads/synch.cc	/^Semaphore::Semaphore(char* debugName, int initialValue)$/;"	f	class:Semaphore	signature:(char* debugName, int initialValue)
Semaphore	threads/synch.h	/^    Semaphore(char* debugName, int initialValue);	\/\/ set initial value$/;"	p	class:Semaphore	access:public	signature:(char* debugName, int initialValue)
Semaphore	threads/synch.h	/^class Semaphore {$/;"	c
Semaphore::P	threads/synch.cc	/^Semaphore::P()$/;"	f	class:Semaphore	signature:()
Semaphore::P	threads/synch.h	/^    void P();	 	\/\/ these are the only operations on a semaphore$/;"	p	class:Semaphore	access:public	signature:()
Semaphore::SelfTest	threads/synch.cc	/^Semaphore::SelfTest()$/;"	f	class:Semaphore	signature:()
Semaphore::SelfTest	threads/synch.h	/^    void SelfTest();	\/\/ test routine for semaphore implementation$/;"	p	class:Semaphore	access:public	signature:()
Semaphore::Semaphore	threads/synch.cc	/^Semaphore::Semaphore(char* debugName, int initialValue)$/;"	f	class:Semaphore	signature:(char* debugName, int initialValue)
Semaphore::Semaphore	threads/synch.h	/^    Semaphore(char* debugName, int initialValue);	\/\/ set initial value$/;"	p	class:Semaphore	access:public	signature:(char* debugName, int initialValue)
Semaphore::V	threads/synch.cc	/^Semaphore::V()$/;"	f	class:Semaphore	signature:()
Semaphore::V	threads/synch.h	/^    void V();	 	\/\/ they are both *atomic*$/;"	p	class:Semaphore	access:public	signature:()
Semaphore::getName	threads/synch.h	/^    char* getName() { return name;}			\/\/ debugging assist$/;"	f	class:Semaphore	access:public	signature:()
Semaphore::name	threads/synch.h	/^    char* name;        \/\/ useful for debugging$/;"	m	class:Semaphore	access:private
Semaphore::queue	threads/synch.h	/^    List<Thread *> *queue;     $/;"	m	class:Semaphore	access:private
Semaphore::value	threads/synch.h	/^    int value;         \/\/ semaphore value, always >= 0$/;"	m	class:Semaphore	access:private
Semaphore::~Semaphore	threads/synch.cc	/^Semaphore::~Semaphore()$/;"	f	class:Semaphore	signature:()
Semaphore::~Semaphore	threads/synch.h	/^    ~Semaphore();   					\/\/ de-allocate semaphore$/;"	p	class:Semaphore	access:public	signature:()
Send	machine/network.cc	/^NetworkOutput::Send(PacketHeader hdr, char* data)$/;"	f	class:NetworkOutput	signature:(PacketHeader hdr, char* data)
Send	machine/network.h	/^    void Send(PacketHeader hdr, char* data);$/;"	p	class:NetworkOutput	access:public	signature:(PacketHeader hdr, char* data)
Send	network/post.cc	/^PostOfficeOutput::Send(PacketHeader pktHdr, MailHeader mailHdr, char* data)$/;"	f	class:PostOfficeOutput	signature:(PacketHeader pktHdr, MailHeader mailHdr, char* data)
Send	network/post.h	/^    void Send(PacketHeader pktHdr, MailHeader mailHdr, char *data);$/;"	p	class:PostOfficeOutput	access:public	signature:(PacketHeader pktHdr, MailHeader mailHdr, char *data)
SendToSocket	lib/sysdep.cc	/^SendToSocket(int sockID, char *buffer, int packetSize, char *toName)$/;"	f	signature:(int sockID, char *buffer, int packetSize, char *toName)
SendToSocket	lib/sysdep.h	/^extern void SendToSocket(int sockID, char *buffer, int packetSize,char *toName);$/;"	p	signature:(int sockID, char *buffer, int packetSize,char *toName)
SetInterrupt	machine/timer.cc	/^Timer::SetInterrupt() $/;"	f	class:Timer	signature:()
SetInterrupt	machine/timer.h	/^    void SetInterrupt();  	\/\/ cause an interrupt to occur in the$/;"	p	class:Timer	access:private	signature:()
SetLevel	machine/interrupt.cc	/^Interrupt::SetLevel(IntStatus now)$/;"	f	class:Interrupt	signature:(IntStatus now)
SetLevel	machine/interrupt.h	/^    IntStatus SetLevel(IntStatus level);$/;"	p	class:Interrupt	access:public	signature:(IntStatus level)
ShortToHost	machine/machine.h	/^unsigned short ShortToHost(unsigned short shortword);$/;"	p	signature:(unsigned short shortword)
ShortToHost	machine/translate.cc	/^ShortToHost(unsigned short shortword) {$/;"	f	signature:(unsigned short shortword)
ShortToMachine	machine/machine.h	/^unsigned short ShortToMachine(unsigned short shortword);$/;"	p	signature:(unsigned short shortword)
ShortToMachine	machine/translate.cc	/^ShortToMachine(unsigned short shortword) { return ShortToHost(shortword); }$/;"	f	signature:(unsigned short shortword)
Signal	threads/synch.cc	/^void Condition::Signal(Lock* conditionLock)$/;"	f	class:Condition	signature:(Lock* conditionLock)
Signal	threads/synch.h	/^    void Signal(Lock *conditionLock);   \/\/ conditionLock must be held by$/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
SimpleThread	threads/thread.cc	/^SimpleThread(int which)$/;"	f	file:	signature:(int which)
Sleep	threads/thread.cc	/^Thread::Sleep (bool finishing)$/;"	f	class:Thread	signature:(bool finishing)
Sleep	threads/thread.h	/^    void Sleep(bool finishing); \/\/ Put the thread to sleep and $/;"	p	class:Thread	access:public	signature:(bool finishing)
SortedList	lib/list.h	/^    SortedList(int (*comp)(T x, T y)) : List<T>() { compare = comp;};$/;"	f	class:SortedList	access:public	signature:(int (*comp)(T x, T y))
SortedList	lib/list.h	/^class SortedList : public List<T> {$/;"	c	inherits:List
SortedList::Append	lib/list.h	/^    void Append(T item) { Insert(item); }   \/\/ neither does *ap*pend $/;"	f	class:SortedList	access:private	signature:(T item)
SortedList::Insert	lib/list.cc	/^SortedList<T>::Insert(T item)$/;"	f	class:SortedList	signature:(T item)
SortedList::Insert	lib/list.h	/^    void Insert(T item); 	\/\/ insert an item onto the list in sorted order$/;"	p	class:SortedList	access:public	signature:(T item)
SortedList::Prepend	lib/list.h	/^    void Prepend(T item) { Insert(item); }  \/\/ *pre*pending has no meaning $/;"	f	class:SortedList	access:private	signature:(T item)
SortedList::SanityCheck	lib/list.cc	/^SortedList<T>::SanityCheck() const$/;"	f	class:SortedList	signature:() const
SortedList::SanityCheck	lib/list.h	/^    void SanityCheck() const;	\/\/ has this list been corrupted?$/;"	p	class:SortedList	access:public	signature:() const
SortedList::SelfTest	lib/list.cc	/^SortedList<T>::SelfTest(T *p, int numEntries)$/;"	f	class:SortedList	signature:(T *p, int numEntries)
SortedList::SelfTest	lib/list.h	/^    void SelfTest(T *p, int numEntries);$/;"	p	class:SortedList	access:public	signature:(T *p, int numEntries)
SortedList::SortedList	lib/list.h	/^    SortedList(int (*comp)(T x, T y)) : List<T>() { compare = comp;};$/;"	f	class:SortedList	access:public	signature:(int (*comp)(T x, T y))
SortedList::compare	lib/list.h	/^    int (*compare)(T x, T y);	\/\/ function for sorting list elements$/;"	m	class:SortedList	access:private
SortedList::~SortedList	lib/list.h	/^    ~SortedList() {};		\/\/ base class destructor called automatically$/;"	f	class:SortedList	access:public	signature:()
SpaceId	userprog/syscall.h	/^typedef int SpaceId;	$/;"	t
StackAllocate	threads/thread.cc	/^Thread::StackAllocate (VoidFunctionPtr func, void *arg)$/;"	f	class:Thread	signature:(VoidFunctionPtr func, void *arg)
StackAllocate	threads/thread.h	/^    void StackAllocate(VoidFunctionPtr func, void *arg);$/;"	p	class:Thread	access:private	signature:(VoidFunctionPtr func, void *arg)
StackReg	machine/machine.h	64;"	d
StackSize	threads/thread.h	/^const int StackSize = (8 * 1024);	\/\/ in words$/;"	v
StartProcess	userprog/ksyscall.h	/^int StartProcess(char path[])$/;"	f	signature:(char path[])
StartupLR	threads/switch.h	221;"	d
StartupPC	threads/switch.h	121;"	d
StartupPC	threads/switch.h	155;"	d
StartupPC	threads/switch.h	257;"	d
StartupPC	threads/switch.h	54;"	d
StartupPC	threads/switch.h	85;"	d
StartupPCState	threads/switch.h	127;"	d
StartupPCState	threads/switch.h	150;"	d
StartupPCState	threads/switch.h	213;"	d
StartupPCState	threads/switch.h	264;"	d
StartupPCState	threads/switch.h	61;"	d
StartupPCState	threads/switch.h	91;"	d
Statistics	machine/stats.cc	/^Statistics::Statistics()$/;"	f	class:Statistics	signature:()
Statistics	machine/stats.h	/^    Statistics(); 		\/\/ initialize everything to zero$/;"	p	class:Statistics	access:public	signature:()
Statistics	machine/stats.h	/^class Statistics {$/;"	c
Statistics::Print	machine/stats.cc	/^Statistics::Print()$/;"	f	class:Statistics	signature:()
Statistics::Print	machine/stats.h	/^    void Print();		\/\/ print collected statistics$/;"	p	class:Statistics	access:public	signature:()
Statistics::Statistics	machine/stats.cc	/^Statistics::Statistics()$/;"	f	class:Statistics	signature:()
Statistics::Statistics	machine/stats.h	/^    Statistics(); 		\/\/ initialize everything to zero$/;"	p	class:Statistics	access:public	signature:()
Statistics::idleTicks	machine/stats.h	/^    int idleTicks;       	\/\/ Time spent idle (no threads to run)$/;"	m	class:Statistics	access:public
Statistics::numConsoleCharsRead	machine/stats.h	/^    int numConsoleCharsRead;	\/\/ number of characters read from the keyboard$/;"	m	class:Statistics	access:public
Statistics::numConsoleCharsWritten	machine/stats.h	/^    int numConsoleCharsWritten; \/\/ number of characters written to the display$/;"	m	class:Statistics	access:public
Statistics::numDiskReads	machine/stats.h	/^    int numDiskReads;		\/\/ number of disk read requests$/;"	m	class:Statistics	access:public
Statistics::numDiskWrites	machine/stats.h	/^    int numDiskWrites;		\/\/ number of disk write requests$/;"	m	class:Statistics	access:public
Statistics::numPacketsRecvd	machine/stats.h	/^    int numPacketsRecvd;	\/\/ number of packets received over the network$/;"	m	class:Statistics	access:public
Statistics::numPacketsSent	machine/stats.h	/^    int numPacketsSent;		\/\/ number of packets sent over the network$/;"	m	class:Statistics	access:public
Statistics::numPageFaults	machine/stats.h	/^    int numPageFaults;		\/\/ number of virtual memory page faults$/;"	m	class:Statistics	access:public
Statistics::systemTicks	machine/stats.h	/^    int systemTicks;	 	\/\/ Time spent executing system code$/;"	m	class:Statistics	access:public
Statistics::totalTicks	machine/stats.h	/^    int totalTicks;      	\/\/ Total time running Nachos$/;"	m	class:Statistics	access:public
Statistics::userTicks	machine/stats.h	/^    int userTicks;       	\/\/ Time spent executing user code$/;"	m	class:Statistics	access:public
SwapHeader	userprog/addrspace.cc	/^SwapHeader (NoffHeader *noffH)$/;"	f	file:	signature:(NoffHeader *noffH)
SynchConsoleInput	userprog/synchconsole.cc	/^SynchConsoleInput::SynchConsoleInput(char *inputFile)$/;"	f	class:SynchConsoleInput	signature:(char *inputFile)
SynchConsoleInput	userprog/synchconsole.h	/^    SynchConsoleInput(char *inputFile); \/\/ Initialize the console device$/;"	p	class:SynchConsoleInput	access:public	signature:(char *inputFile)
SynchConsoleInput	userprog/synchconsole.h	/^class SynchConsoleInput : public CallBackObj {$/;"	c	inherits:CallBackObj
SynchConsoleInput::CallBack	userprog/synchconsole.cc	/^SynchConsoleInput::CallBack()$/;"	f	class:SynchConsoleInput	signature:()
SynchConsoleInput::CallBack	userprog/synchconsole.h	/^    void CallBack();		\/\/ called when a keystroke is available$/;"	p	class:SynchConsoleInput	access:private	signature:()
SynchConsoleInput::GetChar	userprog/synchconsole.cc	/^SynchConsoleInput::GetChar()$/;"	f	class:SynchConsoleInput	signature:()
SynchConsoleInput::GetChar	userprog/synchconsole.h	/^    char GetChar();		\/\/ Read a character, waiting if necessary$/;"	p	class:SynchConsoleInput	access:public	signature:()
SynchConsoleInput::SynchConsoleInput	userprog/synchconsole.cc	/^SynchConsoleInput::SynchConsoleInput(char *inputFile)$/;"	f	class:SynchConsoleInput	signature:(char *inputFile)
SynchConsoleInput::SynchConsoleInput	userprog/synchconsole.h	/^    SynchConsoleInput(char *inputFile); \/\/ Initialize the console device$/;"	p	class:SynchConsoleInput	access:public	signature:(char *inputFile)
SynchConsoleInput::consoleInput	userprog/synchconsole.h	/^    ConsoleInput *consoleInput;	\/\/ the hardware keyboard$/;"	m	class:SynchConsoleInput	access:private
SynchConsoleInput::lock	userprog/synchconsole.h	/^    Lock *lock;			\/\/ only one reader at a time$/;"	m	class:SynchConsoleInput	access:private
SynchConsoleInput::waitFor	userprog/synchconsole.h	/^    Semaphore *waitFor;		\/\/ wait for callBack$/;"	m	class:SynchConsoleInput	access:private
SynchConsoleInput::~SynchConsoleInput	userprog/synchconsole.cc	/^SynchConsoleInput::~SynchConsoleInput()$/;"	f	class:SynchConsoleInput	signature:()
SynchConsoleInput::~SynchConsoleInput	userprog/synchconsole.h	/^    ~SynchConsoleInput();		\/\/ Deallocate console device$/;"	p	class:SynchConsoleInput	access:public	signature:()
SynchConsoleOutput	userprog/synchconsole.cc	/^SynchConsoleOutput::SynchConsoleOutput(char *outputFile)$/;"	f	class:SynchConsoleOutput	signature:(char *outputFile)
SynchConsoleOutput	userprog/synchconsole.h	/^    SynchConsoleOutput(char *outputFile); \/\/ Initialize the console device$/;"	p	class:SynchConsoleOutput	access:public	signature:(char *outputFile)
SynchConsoleOutput	userprog/synchconsole.h	/^class SynchConsoleOutput : public CallBackObj {$/;"	c	inherits:CallBackObj
SynchConsoleOutput::CallBack	userprog/synchconsole.cc	/^SynchConsoleOutput::CallBack()$/;"	f	class:SynchConsoleOutput	signature:()
SynchConsoleOutput::CallBack	userprog/synchconsole.h	/^    void CallBack();		\/\/ called when more data can be written$/;"	p	class:SynchConsoleOutput	access:private	signature:()
SynchConsoleOutput::PutChar	userprog/synchconsole.cc	/^SynchConsoleOutput::PutChar(char ch)$/;"	f	class:SynchConsoleOutput	signature:(char ch)
SynchConsoleOutput::PutChar	userprog/synchconsole.h	/^    void PutChar(char ch);	\/\/ Write a character, waiting if necessary$/;"	p	class:SynchConsoleOutput	access:public	signature:(char ch)
SynchConsoleOutput::SynchConsoleOutput	userprog/synchconsole.cc	/^SynchConsoleOutput::SynchConsoleOutput(char *outputFile)$/;"	f	class:SynchConsoleOutput	signature:(char *outputFile)
SynchConsoleOutput::SynchConsoleOutput	userprog/synchconsole.h	/^    SynchConsoleOutput(char *outputFile); \/\/ Initialize the console device$/;"	p	class:SynchConsoleOutput	access:public	signature:(char *outputFile)
SynchConsoleOutput::consoleOutput	userprog/synchconsole.h	/^    ConsoleOutput *consoleOutput;\/\/ the hardware display$/;"	m	class:SynchConsoleOutput	access:private
SynchConsoleOutput::lock	userprog/synchconsole.h	/^    Lock *lock;			\/\/ only one writer at a time$/;"	m	class:SynchConsoleOutput	access:private
SynchConsoleOutput::waitFor	userprog/synchconsole.h	/^    Semaphore *waitFor;		\/\/ wait for callBack$/;"	m	class:SynchConsoleOutput	access:private
SynchConsoleOutput::~SynchConsoleOutput	userprog/synchconsole.cc	/^SynchConsoleOutput::~SynchConsoleOutput()$/;"	f	class:SynchConsoleOutput	signature:()
SynchConsoleOutput::~SynchConsoleOutput	userprog/synchconsole.h	/^    ~SynchConsoleOutput();$/;"	p	class:SynchConsoleOutput	access:public	signature:()
SynchDisk	filesys/synchdisk.cc	/^SynchDisk::SynchDisk()$/;"	f	class:SynchDisk	signature:()
SynchDisk	filesys/synchdisk.h	/^    SynchDisk();    		        \/\/ Initialize a synchronous disk,$/;"	p	class:SynchDisk	access:public	signature:()
SynchDisk	filesys/synchdisk.h	/^class SynchDisk : public CallBackObj {$/;"	c	inherits:CallBackObj
SynchDisk::CallBack	filesys/synchdisk.cc	/^SynchDisk::CallBack()$/;"	f	class:SynchDisk	signature:()
SynchDisk::CallBack	filesys/synchdisk.h	/^    void CallBack();			\/\/ Called by the disk device interrupt$/;"	p	class:SynchDisk	access:public	signature:()
SynchDisk::ReadSector	filesys/synchdisk.cc	/^SynchDisk::ReadSector(int sectorNumber, char* data)$/;"	f	class:SynchDisk	signature:(int sectorNumber, char* data)
SynchDisk::ReadSector	filesys/synchdisk.h	/^    void ReadSector(int sectorNumber, char* data);$/;"	p	class:SynchDisk	access:public	signature:(int sectorNumber, char* data)
SynchDisk::SynchDisk	filesys/synchdisk.cc	/^SynchDisk::SynchDisk()$/;"	f	class:SynchDisk	signature:()
SynchDisk::SynchDisk	filesys/synchdisk.h	/^    SynchDisk();    		        \/\/ Initialize a synchronous disk,$/;"	p	class:SynchDisk	access:public	signature:()
SynchDisk::WriteSector	filesys/synchdisk.cc	/^SynchDisk::WriteSector(int sectorNumber, char* data)$/;"	f	class:SynchDisk	signature:(int sectorNumber, char* data)
SynchDisk::WriteSector	filesys/synchdisk.h	/^    void WriteSector(int sectorNumber, char* data);$/;"	p	class:SynchDisk	access:public	signature:(int sectorNumber, char* data)
SynchDisk::disk	filesys/synchdisk.h	/^    Disk *disk;		  		\/\/ Raw disk device$/;"	m	class:SynchDisk	access:private
SynchDisk::lock	filesys/synchdisk.h	/^    Lock *lock;		  		\/\/ Only one read\/write request$/;"	m	class:SynchDisk	access:private
SynchDisk::semaphore	filesys/synchdisk.h	/^    Semaphore *semaphore; 		\/\/ To synchronize requesting thread $/;"	m	class:SynchDisk	access:private
SynchDisk::~SynchDisk	filesys/synchdisk.cc	/^SynchDisk::~SynchDisk()$/;"	f	class:SynchDisk	signature:()
SynchDisk::~SynchDisk	filesys/synchdisk.h	/^    ~SynchDisk();			\/\/ De-allocate the synch disk data$/;"	p	class:SynchDisk	access:public	signature:()
SynchList	threads/synchlist.cc	/^SynchList<T>::SynchList()$/;"	f	class:SynchList	signature:()
SynchList	threads/synchlist.h	/^    SynchList();		\/\/ initialize a synchronized list$/;"	p	class:SynchList	access:public	signature:()
SynchList	threads/synchlist.h	/^class SynchList {$/;"	c
SynchList::Append	threads/synchlist.cc	/^SynchList<T>::Append(T item)$/;"	f	class:SynchList	signature:(T item)
SynchList::Append	threads/synchlist.h	/^    void Append(T item);	\/\/ append item to the end of the list,$/;"	p	class:SynchList	access:public	signature:(T item)
SynchList::Apply	threads/synchlist.cc	/^SynchList<T>::Apply(void (*func)(T))$/;"	f	class:SynchList	signature:(void (*func)(T))
SynchList::Apply	threads/synchlist.h	/^    void Apply(void (*f)(T)); \/\/ apply function to all elements in list$/;"	p	class:SynchList	access:public	signature:(void (*f)(T))
SynchList::RemoveFront	threads/synchlist.cc	/^SynchList<T>::RemoveFront()$/;"	f	class:SynchList	signature:()
SynchList::RemoveFront	threads/synchlist.h	/^    T RemoveFront();		\/\/ remove the first item from the front of$/;"	p	class:SynchList	access:public	signature:()
SynchList::SelfTest	threads/synchlist.cc	/^SynchList<T>::SelfTest(T val)$/;"	f	class:SynchList	signature:(T val)
SynchList::SelfTest	threads/synchlist.h	/^    void SelfTest(T value);	\/\/ test the SynchList implementation$/;"	p	class:SynchList	access:public	signature:(T value)
SynchList::SelfTestHelper	threads/synchlist.cc	/^SynchList<T>::SelfTestHelper (void* data) $/;"	f	class:SynchList	signature:(void* data)
SynchList::SelfTestHelper	threads/synchlist.h	/^    static void SelfTestHelper(void* data);$/;"	p	class:SynchList	access:private	signature:(void* data)
SynchList::SynchList	threads/synchlist.cc	/^SynchList<T>::SynchList()$/;"	f	class:SynchList	signature:()
SynchList::SynchList	threads/synchlist.h	/^    SynchList();		\/\/ initialize a synchronized list$/;"	p	class:SynchList	access:public	signature:()
SynchList::list	threads/synchlist.h	/^    List<T> *list;		\/\/ the list of things$/;"	m	class:SynchList	access:private
SynchList::listEmpty	threads/synchlist.h	/^    Condition *listEmpty;	\/\/ wait in Remove if the list is empty$/;"	m	class:SynchList	access:private
SynchList::lock	threads/synchlist.h	/^    Lock *lock;			\/\/ enforce mutual exclusive access to the list$/;"	m	class:SynchList	access:private
SynchList::selfTestPing	threads/synchlist.h	/^    SynchList<T> *selfTestPing;$/;"	m	class:SynchList	access:private
SynchList::~SynchList	threads/synchlist.cc	/^SynchList<T>::~SynchList()$/;"	f	class:SynchList	signature:()
SynchList::~SynchList	threads/synchlist.h	/^    ~SynchList();		\/\/ de-allocate a synchronized list$/;"	p	class:SynchList	access:public	signature:()
SysAdd	userprog/ksyscall.h	/^int SysAdd(int op1, int op2)$/;"	f	signature:(int op1, int op2)
SysGetArray	userprog/ksyscall.h	/^void SysGetArray(int addr, char cArray[], int size)$/;"	f	signature:(int addr, char cArray[], int size)
SysHalt	userprog/ksyscall.h	/^void SysHalt()$/;"	f	signature:()
SyscallException	machine/machine.h	/^		     SyscallException,      \/\/ A program executed a system call.$/;"	e	enum:ExceptionType
SystemMode	machine/interrupt.h	/^enum MachineStatus {IdleMode, SystemMode, UserMode};$/;"	e	enum:MachineStatus
SystemTick	machine/stats.h	/^const int SystemTick =	  10; 	\/\/ advance each time interrupts are enabled$/;"	v
THREAD_C	build.cygwin/Makefile	/^THREAD_C = ..\/threads\/alarm.cc\\$/;"	m
THREAD_C	build.linux/Makefile	/^THREAD_C = ..\/threads\/alarm.cc\\$/;"	m
THREAD_C	build.macosx/Makefile	/^THREAD_C = ..\/threads\/alarm.cc\\$/;"	m
THREAD_H	build.cygwin/Makefile	/^THREAD_H = ..\/threads\/alarm.h\\$/;"	m
THREAD_H	build.linux/Makefile	/^THREAD_H = ..\/threads\/alarm.h\\$/;"	m
THREAD_H	build.macosx/Makefile	/^THREAD_H = ..\/threads\/alarm.h\\$/;"	m
THREAD_H	threads/thread.h	38;"	d
THREAD_O	build.cygwin/Makefile	/^THREAD_O = alarm.o kernel.o main.o scheduler.o synch.o thread.o$/;"	m
THREAD_O	build.linux/Makefile	/^THREAD_O = alarm.o kernel.o main.o scheduler.o synch.o thread.o$/;"	m
THREAD_O	build.macosx/Makefile	/^THREAD_O = alarm.o kernel.o main.o scheduler.o synch.o thread.o$/;"	m
THREAD_S	build.cygwin/Makefile	/^THREAD_S = ..\/threads\/switch.s$/;"	m
THREAD_S	build.linux/Makefile	/^THREAD_S = ..\/threads\/switch.s$/;"	m
THREAD_S	build.macosx/Makefile	/^THREAD_S = ..\/threads\/switch.s$/;"	m
TIMER_H	machine/timer.h	21;"	d
TLBSize	machine/machine.h	/^const int TLBSize = 4;			\/\/ if there is a TLB, make it small$/;"	v
TLB_H	machine/translate.h	19;"	d
TOC	threads/switch.h	205;"	d
TRUE	lib/utility.h	16;"	d
Tell	lib/sysdep.cc	/^Tell(int fd)$/;"	f	signature:(int fd)
Tell	lib/sysdep.h	/^extern int Tell(int fd);$/;"	p	signature:(int fd)
Test	lib/bitmap.cc	/^Bitmap::Test(int which) const$/;"	f	class:Bitmap	signature:(int which) const
Test	lib/bitmap.h	/^    bool Test(int which) const;	\/\/ Is the "nth" bit set?$/;"	p	class:Bitmap	access:public	signature:(int which) const
Thread	threads/thread.cc	/^Thread::Thread(char* threadName)$/;"	f	class:Thread	signature:(char* threadName)
Thread	threads/thread.h	/^    Thread(char* debugName);		\/\/ initialize a Thread $/;"	p	class:Thread	access:public	signature:(char* debugName)
Thread	threads/thread.h	/^class Thread {$/;"	c
Thread::Begin	threads/thread.cc	/^Thread::Begin ()$/;"	f	class:Thread	signature:()
Thread::Begin	threads/thread.h	/^    void Begin();		\/\/ Startup code for the thread	$/;"	p	class:Thread	access:public	signature:()
Thread::CheckOverflow	threads/thread.cc	/^Thread::CheckOverflow()$/;"	f	class:Thread	signature:()
Thread::CheckOverflow	threads/thread.h	/^    void CheckOverflow();   	\/\/ Check if thread stack has overflowed$/;"	p	class:Thread	access:public	signature:()
Thread::Finish	threads/thread.cc	/^Thread::Finish ()$/;"	f	class:Thread	signature:()
Thread::Finish	threads/thread.h	/^    void Finish();  		\/\/ The thread is done executing$/;"	p	class:Thread	access:public	signature:()
Thread::Fork	threads/thread.cc	/^Thread::Fork(VoidFunctionPtr func, void *arg)$/;"	f	class:Thread	signature:(VoidFunctionPtr func, void *arg)
Thread::Fork	threads/thread.h	/^    void Fork(VoidFunctionPtr func, void *arg); $/;"	p	class:Thread	access:public	signature:(VoidFunctionPtr func, void *arg)
Thread::Print	threads/thread.h	/^    void Print() { cout << name; }$/;"	f	class:Thread	access:public	signature:()
Thread::RestoreUserState	threads/thread.cc	/^Thread::RestoreUserState()$/;"	f	class:Thread	signature:()
Thread::RestoreUserState	threads/thread.h	/^    void RestoreUserState();		\/\/ restore user-level register state$/;"	p	class:Thread	access:public	signature:()
Thread::SaveUserState	threads/thread.cc	/^Thread::SaveUserState()$/;"	f	class:Thread	signature:()
Thread::SaveUserState	threads/thread.h	/^    void SaveUserState();		\/\/ save user-level register state$/;"	p	class:Thread	access:public	signature:()
Thread::SelfTest	threads/thread.cc	/^Thread::SelfTest()$/;"	f	class:Thread	signature:()
Thread::SelfTest	threads/thread.h	/^    void SelfTest();		\/\/ test whether thread impl is working$/;"	p	class:Thread	access:public	signature:()
Thread::Sleep	threads/thread.cc	/^Thread::Sleep (bool finishing)$/;"	f	class:Thread	signature:(bool finishing)
Thread::Sleep	threads/thread.h	/^    void Sleep(bool finishing); \/\/ Put the thread to sleep and $/;"	p	class:Thread	access:public	signature:(bool finishing)
Thread::StackAllocate	threads/thread.cc	/^Thread::StackAllocate (VoidFunctionPtr func, void *arg)$/;"	f	class:Thread	signature:(VoidFunctionPtr func, void *arg)
Thread::StackAllocate	threads/thread.h	/^    void StackAllocate(VoidFunctionPtr func, void *arg);$/;"	p	class:Thread	access:private	signature:(VoidFunctionPtr func, void *arg)
Thread::Thread	threads/thread.cc	/^Thread::Thread(char* threadName)$/;"	f	class:Thread	signature:(char* threadName)
Thread::Thread	threads/thread.h	/^    Thread(char* debugName);		\/\/ initialize a Thread $/;"	p	class:Thread	access:public	signature:(char* debugName)
Thread::Yield	threads/thread.cc	/^Thread::Yield ()$/;"	f	class:Thread	signature:()
Thread::Yield	threads/thread.h	/^    void Yield();  		\/\/ Relinquish the CPU if any $/;"	p	class:Thread	access:public	signature:()
Thread::getName	threads/thread.h	/^    char* getName() { return (name); }$/;"	f	class:Thread	access:public	signature:()
Thread::machineState	threads/thread.h	/^    void *machineState[MachineStateSize];  \/\/ all registers except for stackTop$/;"	m	class:Thread	access:private
Thread::name	threads/thread.h	/^    char* name;$/;"	m	class:Thread	access:private
Thread::setStatus	threads/thread.h	/^    void setStatus(ThreadStatus st) { status = st; }$/;"	f	class:Thread	access:public	signature:(ThreadStatus st)
Thread::space	threads/thread.h	/^    AddrSpace *space;			\/\/ User code this thread is running.$/;"	m	class:Thread	access:public
Thread::stack	threads/thread.h	/^    int *stack; 	 	\/\/ Bottom of the stack $/;"	m	class:Thread	access:private
Thread::stackTop	threads/thread.h	/^    int *stackTop;			 \/\/ the current stack pointer$/;"	m	class:Thread	access:private
Thread::status	threads/thread.h	/^    ThreadStatus status;	\/\/ ready, running or blocked$/;"	m	class:Thread	access:private
Thread::userRegisters	threads/thread.h	/^    int userRegisters[NumTotalRegs];	\/\/ user-level CPU register state$/;"	m	class:Thread	access:private
Thread::~Thread	threads/thread.cc	/^Thread::~Thread()$/;"	f	class:Thread	signature:()
Thread::~Thread	threads/thread.h	/^    ~Thread(); 				\/\/ deallocate a Thread$/;"	p	class:Thread	access:public	signature:()
ThreadBegin	threads/thread.cc	/^static void ThreadBegin() { kernel->currentThread->Begin(); }$/;"	f	file:	signature:()
ThreadExit	test/start.S	/^ThreadExit:$/;"	l
ThreadExit	userprog/syscall.h	/^void ThreadExit(int ExitCode);	$/;"	p	signature:(int ExitCode)
ThreadFinish	threads/thread.cc	/^static void ThreadFinish()    { kernel->currentThread->Finish(); }$/;"	f	file:	signature:()
ThreadFork	test/start.S	/^ThreadFork:$/;"	l
ThreadFork	userprog/syscall.h	/^ThreadId ThreadFork(void (*func)());$/;"	p	signature:(void (*func)())
ThreadId	userprog/syscall.h	/^typedef int ThreadId;$/;"	t
ThreadJoin	test/start.S	/^ThreadJoin:$/;"	l
ThreadJoin	userprog/syscall.h	/^int ThreadJoin(ThreadId id);$/;"	p	signature:(ThreadId id)
ThreadPrint	threads/thread.cc	/^void ThreadPrint(Thread *t) { t->Print(); }$/;"	f	signature:(Thread *t)
ThreadPrint	threads/thread.h	/^extern void ThreadPrint(Thread *thread);	 $/;"	p	signature:(Thread *thread)
ThreadRoot	threads/switch.S	/^ThreadRoot$/;"	l
ThreadRoot	threads/switch.S	/^ThreadRoot:$/;"	l
ThreadRoot	threads/thread.h	/^void ThreadRoot();$/;"	p	signature:()
ThreadSelfTest	threads/kernel.cc	/^Kernel::ThreadSelfTest() {$/;"	f	class:Kernel	signature:()
ThreadSelfTest	threads/kernel.h	/^    void ThreadSelfTest();	\/\/ self test of threads and synchronization$/;"	p	class:Kernel	access:public	signature:()
ThreadStatus	threads/thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	g
ThreadYield	test/start.S	/^ThreadYield:$/;"	l
ThreadYield	userprog/syscall.h	/^void ThreadYield();	$/;"	p	signature:()
TimeToSeek	machine/disk.cc	/^Disk::TimeToSeek(int newSector, int *rotation) $/;"	f	class:Disk	signature:(int newSector, int *rotation)
TimeToSeek	machine/disk.h	/^    int TimeToSeek(int newSector, int *rotate); \/\/ time to get to the new track$/;"	p	class:Disk	access:private	signature:(int newSector, int *rotate)
Timer	machine/timer.cc	/^Timer::Timer(bool doRandom, CallBackObj *toCall)$/;"	f	class:Timer	signature:(bool doRandom, CallBackObj *toCall)
Timer	machine/timer.h	/^    Timer(bool doRandom, CallBackObj *toCall);$/;"	p	class:Timer	access:public	signature:(bool doRandom, CallBackObj *toCall)
Timer	machine/timer.h	/^class Timer : public CallBackObj {$/;"	c	inherits:CallBackObj
Timer::CallBack	machine/timer.cc	/^Timer::CallBack() $/;"	f	class:Timer	signature:()
Timer::CallBack	machine/timer.h	/^    void CallBack();		\/\/ called internally when the hardware$/;"	p	class:Timer	access:private	signature:()
Timer::Disable	machine/timer.h	/^    void Disable() { disable = TRUE; }$/;"	f	class:Timer	access:public	signature:()
Timer::SetInterrupt	machine/timer.cc	/^Timer::SetInterrupt() $/;"	f	class:Timer	signature:()
Timer::SetInterrupt	machine/timer.h	/^    void SetInterrupt();  	\/\/ cause an interrupt to occur in the$/;"	p	class:Timer	access:private	signature:()
Timer::Timer	machine/timer.cc	/^Timer::Timer(bool doRandom, CallBackObj *toCall)$/;"	f	class:Timer	signature:(bool doRandom, CallBackObj *toCall)
Timer::Timer	machine/timer.h	/^    Timer(bool doRandom, CallBackObj *toCall);$/;"	p	class:Timer	access:public	signature:(bool doRandom, CallBackObj *toCall)
Timer::callPeriodically	machine/timer.h	/^    CallBackObj *callPeriodically; \/\/ call this every TimerTicks time units $/;"	m	class:Timer	access:private
Timer::disable	machine/timer.h	/^    bool disable;		\/\/ turn off the timer device after next$/;"	m	class:Timer	access:private
Timer::randomize	machine/timer.h	/^    bool randomize;		\/\/ set if we need to use a random timeout delay$/;"	m	class:Timer	access:private
Timer::~Timer	machine/timer.h	/^    virtual ~Timer() {}$/;"	f	class:Timer	access:public	signature:()
TimerInt	machine/interrupt.h	/^enum IntType { TimerInt, DiskInt, ConsoleWriteInt, ConsoleReadInt, $/;"	e	enum:IntType
TimerTicks	machine/stats.h	/^const int TimerTicks = 	 100;  	\/\/ (average) time between timer interrupts$/;"	v
TransferSize	threads/main.cc	/^static const int TransferSize = 128;$/;"	v	file:
Translate	machine/machine.h	/^    ExceptionType Translate(int virtAddr, int* physAddr, int size,bool writing);$/;"	p	class:Machine	access:private	signature:(int virtAddr, int* physAddr, int size,bool writing)
Translate	machine/translate.cc	/^Machine::Translate(int virtAddr, int* physAddr, int size, bool writing)$/;"	f	class:Machine	signature:(int virtAddr, int* physAddr, int size, bool writing)
Translate	userprog/addrspace.cc	/^AddrSpace::Translate(unsigned int vaddr, unsigned int *paddr, int isReadWrite)$/;"	f	class:AddrSpace	signature:(unsigned int vaddr, unsigned int *paddr, int isReadWrite)
Translate	userprog/addrspace.h	/^    ExceptionType Translate(unsigned int vaddr, unsigned int *paddr, int mode);$/;"	p	class:AddrSpace	access:public	signature:(unsigned int vaddr, unsigned int *paddr, int mode)
TranslationEntry	machine/translate.h	/^class TranslationEntry {$/;"	c
TranslationEntry::dirty	machine/translate.h	/^    bool dirty;         \/\/ This bit is set by the hardware every time the$/;"	m	class:TranslationEntry	access:public
TranslationEntry::physicalPage	machine/translate.h	/^    int physicalPage;  	\/\/ The page number in real memory (relative to the$/;"	m	class:TranslationEntry	access:public
TranslationEntry::readOnly	machine/translate.h	/^    bool readOnly;	\/\/ If this bit is set, the user program is not allowed$/;"	m	class:TranslationEntry	access:public
TranslationEntry::use	machine/translate.h	/^    bool use;           \/\/ This bit is set by the hardware every time the$/;"	m	class:TranslationEntry	access:public
TranslationEntry::valid	machine/translate.h	/^    bool valid;         \/\/ If this bit is set, the translation is ignored.$/;"	m	class:TranslationEntry	access:public
TranslationEntry::virtualPage	machine/translate.h	/^    int virtualPage;  	\/\/ The page number in virtual memory.$/;"	m	class:TranslationEntry	access:public
TypeToReg	machine/mipssim.cc	/^TypeToReg(RegType reg, Instruction *instr)$/;"	f	file:	signature:(RegType reg, Instruction *instr)
UDelay	lib/sysdep.cc	/^UDelay(unsigned int useconds)$/;"	f	signature:(unsigned int useconds)
UDelay	lib/sysdep.h	/^extern void UDelay(unsigned int usec);\/\/ rcgood - to avoid spinners.$/;"	p	signature:(unsigned int usec)
UNIMPLEMENTED	lib/debug.h	90;"	d
USERPROG_C	build.cygwin/Makefile	/^USERPROG_C = ..\/userprog\/addrspace.cc\\$/;"	m
USERPROG_C	build.linux/Makefile	/^USERPROG_C = ..\/userprog\/addrspace.cc\\$/;"	m
USERPROG_C	build.macosx/Makefile	/^USERPROG_C = ..\/userprog\/addrspace.cc\\$/;"	m
USERPROG_H	build.cygwin/Makefile	/^USERPROG_H = ..\/userprog\/addrspace.h\\$/;"	m
USERPROG_H	build.linux/Makefile	/^USERPROG_H = ..\/userprog\/addrspace.h\\$/;"	m
USERPROG_H	build.macosx/Makefile	/^USERPROG_H = ..\/userprog\/addrspace.h\\$/;"	m
USERPROG_O	build.cygwin/Makefile	/^USERPROG_O = addrspace.o exception.o synchconsole.o$/;"	m
USERPROG_O	build.linux/Makefile	/^USERPROG_O = addrspace.o exception.o synchconsole.o$/;"	m
USERPROG_O	build.macosx/Makefile	/^USERPROG_O = addrspace.o exception.o synchconsole.o$/;"	m
UTILITY_H	lib/utility.h	9;"	d
Unlink	lib/sysdep.cc	/^Unlink(char *name)$/;"	f	signature:(char *name)
Unlink	lib/sysdep.h	/^extern bool Unlink(char *name);$/;"	p	signature:(char *name)
UpdateLast	machine/disk.cc	/^Disk::UpdateLast(int newSector)$/;"	f	class:Disk	signature:(int newSector)
UpdateLast	machine/disk.h	/^    void UpdateLast(int newSector);$/;"	p	class:Disk	access:private	signature:(int newSector)
UserMode	machine/interrupt.h	/^enum MachineStatus {IdleMode, SystemMode, UserMode};$/;"	e	enum:MachineStatus
UserStackSize	userprog/addrspace.h	19;"	d
UserTick	machine/stats.h	/^const int UserTick = 	   1;	\/\/ advance for each user-level instruction $/;"	v
V	threads/synch.cc	/^Semaphore::V()$/;"	f	class:Semaphore	signature:()
V	threads/synch.h	/^    void V();	 	\/\/ they are both *atomic*$/;"	p	class:Semaphore	access:public	signature:()
VoidFunctionPtr	lib/utility.h	/^typedef void (*VoidFunctionPtr)(void *arg); $/;"	t
VoidNoArgFunctionPtr	lib/utility.h	/^typedef void (*VoidNoArgFunctionPtr)(); $/;"	t
Wait	threads/synch.cc	/^void Condition::Wait(Lock* conditionLock) $/;"	f	class:Condition	signature:(Lock* conditionLock)
Wait	threads/synch.h	/^    void Wait(Lock *conditionLock); 	\/\/ these are the 3 operations on $/;"	p	class:Condition	access:public	signature:(Lock *conditionLock)
WaitUntil	threads/alarm.h	/^    void WaitUntil(int x);	\/\/ suspend execution until time > now + x$/;"	p	class:Alarm	access:public	signature:(int x)
WhenDoneLR	threads/switch.h	220;"	d
WhenDonePC	threads/switch.h	120;"	d
WhenDonePC	threads/switch.h	154;"	d
WhenDonePC	threads/switch.h	256;"	d
WhenDonePC	threads/switch.h	53;"	d
WhenDonePC	threads/switch.h	84;"	d
WhenDonePCState	threads/switch.h	126;"	d
WhenDonePCState	threads/switch.h	149;"	d
WhenDonePCState	threads/switch.h	212;"	d
WhenDonePCState	threads/switch.h	263;"	d
WhenDonePCState	threads/switch.h	60;"	d
WhenDonePCState	threads/switch.h	90;"	d
WordToHost	machine/machine.h	/^unsigned int WordToHost(unsigned int word);$/;"	p	signature:(unsigned int word)
WordToHost	machine/translate.cc	/^WordToHost(unsigned int word) {$/;"	f	signature:(unsigned int word)
WordToMachine	machine/machine.h	/^unsigned int WordToMachine(unsigned int word);$/;"	p	signature:(unsigned int word)
WordToMachine	machine/translate.cc	/^WordToMachine(unsigned int word) { return WordToHost(word); }$/;"	f	signature:(unsigned int word)
Write	filesys/openfile.cc	/^OpenFile::Write(char *into, int numBytes)$/;"	f	class:OpenFile	signature:(char *into, int numBytes)
Write	filesys/openfile.h	/^    int Write(char *from, int numBytes) {$/;"	f	class:OpenFile	access:public	signature:(char *from, int numBytes)
Write	filesys/openfile.h	/^    int Write(char *from, int numBytes);$/;"	p	class:OpenFile	access:public	signature:(char *from, int numBytes)
Write	test/start.S	/^Write:$/;"	l
Write	userprog/syscall.h	/^int Write(char *buffer, int size, OpenFileId id);$/;"	p	signature:(char *buffer, int size, OpenFileId id)
WriteAt	filesys/openfile.cc	/^OpenFile::WriteAt(char *from, int numBytes, int position)$/;"	f	class:OpenFile	signature:(char *from, int numBytes, int position)
WriteAt	filesys/openfile.h	/^    int WriteAt(char *from, int numBytes, int position) { $/;"	f	class:OpenFile	access:public	signature:(char *from, int numBytes, int position)
WriteAt	filesys/openfile.h	/^    int WriteAt(char *from, int numBytes, int position);$/;"	p	class:OpenFile	access:public	signature:(char *from, int numBytes, int position)
WriteBack	filesys/directory.cc	/^Directory::WriteBack(OpenFile *file)$/;"	f	class:Directory	signature:(OpenFile *file)
WriteBack	filesys/directory.h	/^    void WriteBack(OpenFile *file);	\/\/ Write modifications to $/;"	p	class:Directory	access:public	signature:(OpenFile *file)
WriteBack	filesys/filehdr.cc	/^FileHeader::WriteBack(int sector)$/;"	f	class:FileHeader	signature:(int sector)
WriteBack	filesys/filehdr.h	/^    void WriteBack(int sectorNumber); 	\/\/ Write modifications to file header$/;"	p	class:FileHeader	access:public	signature:(int sectorNumber)
WriteBack	filesys/pbitmap.cc	/^PersistentBitmap::WriteBack(OpenFile *file)$/;"	f	class:PersistentBitmap	signature:(OpenFile *file)
WriteBack	filesys/pbitmap.h	/^    void WriteBack(OpenFile *file); 	\/\/ write bitmap contents to disk $/;"	p	class:PersistentBitmap	access:public	signature:(OpenFile *file)
WriteFile	lib/sysdep.cc	/^WriteFile(int fd, char *buffer, int nBytes)$/;"	f	signature:(int fd, char *buffer, int nBytes)
WriteFile	lib/sysdep.h	/^extern void WriteFile(int fd, char *buffer, int nBytes);$/;"	p	signature:(int fd, char *buffer, int nBytes)
WriteMem	machine/machine.h	/^    bool WriteMem(int addr, int size, int value);$/;"	p	class:Machine	access:public	signature:(int addr, int size, int value)
WriteMem	machine/translate.cc	/^Machine::WriteMem(int addr, int size, int value)$/;"	f	class:Machine	signature:(int addr, int size, int value)
WriteRegister	machine/machine.cc	/^Machine::WriteRegister(int num, int value)$/;"	f	class:Machine	signature:(int num, int value)
WriteRegister	machine/machine.h	/^    void WriteRegister(int num, int value);$/;"	p	class:Machine	access:public	signature:(int num, int value)
WriteRequest	machine/disk.cc	/^Disk::WriteRequest(int sectorNumber, char* data)$/;"	f	class:Disk	signature:(int sectorNumber, char* data)
WriteRequest	machine/disk.h	/^    void WriteRequest(int sectorNumber, char* data);$/;"	p	class:Disk	access:public	signature:(int sectorNumber, char* data)
WriteSector	filesys/synchdisk.cc	/^SynchDisk::WriteSector(int sectorNumber, char* data)$/;"	f	class:SynchDisk	signature:(int sectorNumber, char* data)
WriteSector	filesys/synchdisk.h	/^    void WriteSector(int sectorNumber, char* data);$/;"	p	class:SynchDisk	access:public	signature:(int sectorNumber, char* data)
Yield	threads/thread.cc	/^Thread::Yield ()$/;"	f	class:Thread	signature:()
Yield	threads/thread.h	/^    void Yield();  		\/\/ Relinquish the CPU if any $/;"	p	class:Thread	access:public	signature:()
YieldOnReturn	machine/interrupt.cc	/^Interrupt::YieldOnReturn()$/;"	f	class:Interrupt	signature:()
YieldOnReturn	machine/interrupt.h	/^    void YieldOnReturn();	\/\/ cause a context switch on return $/;"	p	class:Interrupt	access:public	signature:()
_EAX	threads/switch.h	135;"	d
_EBP	threads/switch.h	139;"	d
_EBX	threads/switch.h	136;"	d
_ECX	threads/switch.h	137;"	d
_EDI	threads/switch.h	141;"	d
_EDX	threads/switch.h	138;"	d
_ESI	threads/switch.h	140;"	d
_ESP	threads/switch.h	134;"	d
_PC	threads/switch.h	142;"	d
_SWITCH	threads/switch.S	/^_SWITCH:		$/;"	l
_SWITCH	threads/switch.S	/^_SWITCH:$/;"	l
_ThreadRoot	threads/switch.S	/^_ThreadRoot:	$/;"	l
_ThreadRoot	threads/switch.S	/^_ThreadRoot:$/;"	l
__USERPROG_KSYSCALL_H__	userprog/ksyscall.h	12;"	d
__main	test/start.S	/^__main:$/;"	l
__start	test/start.S	/^__start:$/;"	l
a0	threads/switch.S	/^#define a0	$16	\/* (T)		argument registers	*\/$/;"	d
a0	threads/switch.S	/^#define a0      $4      \/* argument registers *\/$/;"	d
a1	threads/switch.S	/^#define a1	$17$/;"	d
a1	threads/switch.S	/^#define a1      $5$/;"	d
abs	lib/sysdep.h	/^int abs(int i);$/;"	p	signature:(int i)
active	machine/disk.h	/^    bool active;     			\/\/ Is a disk operation in progress?$/;"	m	class:Disk	access:private
ai	threads/switch.S	/^#define ai	$25	\/* (T)		argument information	*\/$/;"	d
alarm	threads/kernel.h	/^    Alarm *alarm;		\/\/ the software alarm clock    $/;"	m	class:Kernel	access:public
args	machine/mipssim.h	/^    RegType args[3];$/;"	m	struct:OpString	access:public
atof	lib/sysdep.h	/^double atof(const char *str);$/;"	p	signature:(const char *str)
atoi	lib/sysdep.h	/^int atoi(const char *str);$/;"	p	signature:(const char *str)
bcopy	lib/sysdep.h	/^void bcopy(const void *s1, void *s2, size_t n);$/;"	p	signature:(const void *s1, void *s2, size_t n)
bind	lib/sysdep.cc	/^int bind (int, const void*, int);$/;"	p	file:	signature:(int, const void*, int)
blah	test/segments.c	/^const int blah = 0xff;               \/* into .rdata segment                   *\/$/;"	v
boxes	network/post.h	/^    MailBox *boxes;		\/\/ Table of mail boxes to hold incoming mail$/;"	m	class:PostOfficeInput	access:private
bucket	lib/hash.h	/^    int bucket;			\/\/ current bucket we are in$/;"	m	class:HashIterator	access:private
bucketIter	lib/hash.h	/^    ListIterator<T> *bucketIter; \/\/ where we are in the bucket$/;"	m	class:HashIterator	access:private
buckets	lib/hash.h	/^    Bucket *buckets;		\/\/ the array of hash buckets$/;"	m	class:HashTable	access:private
bufferInit	machine/disk.h	/^    int bufferInit;			\/\/ When the track buffer started $/;"	m	class:Disk	access:private
bzero	lib/sysdep.h	/^void bzero(void *s, size_t n);$/;"	p	signature:(void *s, size_t n)
callOnInterrupt	machine/interrupt.h	/^    CallBackObj *callOnInterrupt;\/\/ The object (in the hardware device$/;"	m	class:PendingInterrupt	access:public
callPeriodically	machine/timer.h	/^    CallBackObj *callPeriodically; \/\/ call this every TimerTicks time units $/;"	m	class:Timer	access:private
callWhenAvail	machine/console.h	/^    CallBackObj *callWhenAvail;		\/\/ Interrupt handler to call when $/;"	m	class:ConsoleInput	access:private
callWhenAvail	machine/network.h	/^    CallBackObj *callWhenAvail; \/\/ Interrupt handler, signalling packet has $/;"	m	class:NetworkInput	access:private
callWhenDone	machine/console.h	/^    CallBackObj *callWhenDone;		\/\/ Interrupt handler to call when $/;"	m	class:ConsoleOutput	access:private
callWhenDone	machine/disk.h	/^    CallBackObj *callWhenDone;		\/\/ Invoke when any disk request finishes$/;"	m	class:Disk	access:private
callWhenDone	machine/network.h	/^    CallBackObj *callWhenDone;  \/\/ Interrupt handler, signalling next packet $/;"	m	class:NetworkOutput	access:private
chanceToWork	machine/network.h	/^    double chanceToWork;	\/\/ Likelihood packet will be dropped$/;"	m	class:NetworkOutput	access:private
code	userprog/noff.h	/^   Segment code;		\/* executable code segment *\/ $/;"	m	struct:noffHeader	access:public
compare	lib/list.h	/^    int (*compare)(T x, T y);	\/\/ function for sorting list elements$/;"	m	class:SortedList	access:private
consoleIn	threads/kernel.h	/^    char *consoleIn;            \/\/ file to read console input from$/;"	m	class:Kernel	access:private
consoleInput	userprog/synchconsole.h	/^    ConsoleInput *consoleInput;	\/\/ the hardware keyboard$/;"	m	class:SynchConsoleInput	access:private
consoleOut	threads/kernel.h	/^    char *consoleOut;           \/\/ file to send console output to$/;"	m	class:Kernel	access:private
consoleOutput	userprog/synchconsole.h	/^    ConsoleOutput *consoleOutput;\/\/ the hardware display$/;"	m	class:SynchConsoleOutput	access:private
copyright	lib/copyright.h	/^static char *copyright = "Copyright (c) 1992-1993 The Regents of the University of California.  All rights reserved.";$/;"	v
current	lib/list.h	/^    ListElement<T> *current;	\/\/ where we are in the list$/;"	m	class:ListIterator	access:private
currentOffset	filesys/openfile.h	/^    int currentOffset;$/;"	m	class:OpenFile	access:private
currentThread	threads/kernel.h	/^    Thread *currentThread;	\/\/ the thread holding the CPU$/;"	m	class:Kernel	access:public
data	network/post.h	/^     char data[MaxMailSize];	\/\/ Payload -- message data$/;"	m	class:Mail	access:public
dataSectors	filesys/filehdr.h	/^    int dataSectors[NumDirect];		\/\/ Disk sector numbers for each data $/;"	m	class:FileHeader	access:private
dbgAddr	lib/debug.h	/^const char dbgAddr = 'a'; 		\/\/ address spaces$/;"	v
dbgAll	lib/debug.h	/^const char dbgAll = '+';		\/\/ turn on all debug messages$/;"	v
dbgDisk	lib/debug.h	/^const char dbgDisk = 'd'; 		\/\/ disk emulation$/;"	v
dbgFile	lib/debug.h	/^const char dbgFile = 'f'; 		\/\/ file system$/;"	v
dbgInt	lib/debug.h	/^const char dbgInt = 'i'; 		\/\/ interrupt emulation$/;"	v
dbgMach	lib/debug.h	/^const char dbgMach = 'm'; 		\/\/ machine emulation$/;"	v
dbgNet	lib/debug.h	/^const char dbgNet = 'n'; 		\/\/ network emulation$/;"	v
dbgSynch	lib/debug.h	/^const char dbgSynch = 's';		\/\/ locks, semaphores, condition vars$/;"	v
dbgSys	lib/debug.h	/^const char dbgSys = 'u';                \/\/ systemcall$/;"	v
dbgThread	lib/debug.h	/^const char dbgThread = 't';		\/\/ threads$/;"	v
debug	threads/main.cc	/^Debug *debug;$/;"	v
debugUserProg	threads/kernel.h	/^    bool debugUserProg;         \/\/ single step user program$/;"	m	class:Kernel	access:private
directoryFile	filesys/filesys.h	/^   OpenFile* directoryFile;		\/\/ "Root" directory -- list of $/;"	m	class:FileSystem	access:private
dirty	machine/translate.h	/^    bool dirty;         \/\/ This bit is set by the hardware every time the$/;"	m	class:TranslationEntry	access:public
disable	machine/timer.h	/^    bool disable;		\/\/ turn off the timer device after next$/;"	m	class:Timer	access:private
disk	filesys/synchdisk.h	/^    Disk *disk;		  		\/\/ Raw disk device$/;"	m	class:SynchDisk	access:private
diskname	machine/disk.h	/^    char diskname[32];			\/\/ name of simulated disk's file$/;"	m	class:Disk	access:private
divRoundDown	lib/utility.h	24;"	d
divRoundUp	lib/utility.h	25;"	d
enableFlags	lib/debug.h	/^    char *enableFlags;		\/\/ controls which DEBUG messages are printed$/;"	m	class:Debug	access:private
exceptionNames	machine/machine.cc	/^static char* exceptionNames[] = { "no exception", "syscall", $/;"	v	file:
extra	machine/mipssim.cc	/^    int extra;       \/\/ Immediate or target or shamt field or offset.$/;"	m	class:Instruction	file:	access:public
file	filesys/openfile.h	/^    int file;$/;"	m	class:OpenFile	access:private
fileSystem	threads/kernel.h	/^    FileSystem *fileSystem;     $/;"	m	class:Kernel	access:public
fileno	machine/disk.h	/^    int fileno;				\/\/ UNIX file number for simulated disk $/;"	m	class:Disk	access:private
first	lib/list.h	/^    ListElement<T> *first;  	\/\/ Head of the list, NULL if list is empty$/;"	m	class:List	access:protected
format	machine/mipssim.h	/^    char *format;	\/\/ Printed version of instruction$/;"	m	struct:OpString	access:public
format	machine/mipssim.h	/^    int format;		\/* Format type (IFMT or JFMT or RFMT) *\/$/;"	m	struct:OpInfo	access:public
formatFlag	threads/kernel.h	/^    bool formatFlag;          \/\/ format the disk if this is true$/;"	m	class:Kernel	access:private
fp	threads/switch.S	/^#define fp      $30     \/* frame pointer *\/$/;"	d
freeMapFile	filesys/filesys.h	/^   OpenFile* freeMapFile;		\/\/ Bit map of free disk blocks,$/;"	m	class:FileSystem	access:private
from	machine/network.h	/^    NetworkAddress from;	\/\/ source machine ID$/;"	m	class:PacketHeader	access:public
from	network/post.h	/^    MailBoxAddress from;	\/\/ Mail box to reply to$/;"	m	class:MailHeader	access:public
getKey	lib/hash.h	/^    Key (*getKey)(T x);		\/\/ get Key from value$/;"	m	class:HashTable	access:private
getLevel	machine/interrupt.h	/^    IntStatus getLevel() {return level;}$/;"	f	class:Interrupt	access:public	signature:()
getName	threads/synch.h	/^    char* getName() { return (name); }$/;"	f	class:Condition	access:public	signature:()
getName	threads/synch.h	/^    char* getName() { return name; }	\/\/ debugging assist$/;"	f	class:Lock	access:public	signature:()
getName	threads/synch.h	/^    char* getName() { return name;}			\/\/ debugging assist$/;"	f	class:Semaphore	access:public	signature:()
getName	threads/thread.h	/^    char* getName() { return (name); }$/;"	f	class:Thread	access:public	signature:()
getStatus	machine/interrupt.h	/^    MachineStatus getStatus() { return status; } $/;"	f	class:Interrupt	access:public	signature:()
getpagesize	lib/sysdep.cc	/^  size_t getpagesize(void);$/;"	p	file:	signature:(void)
getpagesize	lib/sysdep.cc	/^ int getpagesize(void);$/;"	p	file:	signature:(void)
gp	threads/switch.S	/^#define	gp	$29	\/* (T)		(local) data pointer	*\/$/;"	d
hash	lib/hash.h	/^    unsigned (*hash)(Key x);	\/\/ the hash function$/;"	m	class:HashTable	access:private
hashTestVector	lib/libtest.cc	/^static char *hashTestVector[] = { "0", "1", "2", "3", "4", "5", "6",$/;"	v	file:
hdr	filesys/openfile.h	/^    FileHeader *hdr;			\/\/ Header for this file $/;"	m	class:OpenFile	access:private
hostName	threads/kernel.h	/^    int hostName;               \/\/ machine identifier$/;"	m	class:Kernel	access:public
idleTicks	machine/stats.h	/^    int idleTicks;       	\/\/ Time spent idle (no threads to run)$/;"	m	class:Statistics	access:public
inFileAddr	userprog/noff.h	/^  int inFileAddr;		\/* location of segment in this file *\/$/;"	m	struct:segment	access:public
inHandler	machine/interrupt.h	/^    bool inHandler;		\/\/ TRUE if we are running an interrupt handler$/;"	m	class:Interrupt	access:private
inHdr	machine/network.h	/^    PacketHeader inHdr;		\/\/ Information about arrived packet$/;"	m	class:NetworkInput	access:private
inUse	filesys/directory.h	/^    bool inUse;				\/\/ Is this directory entry in use?$/;"	m	class:DirectoryEntry	access:public
inbox	machine/network.h	/^    char inbox[MaxPacketSize];  \/\/ Data for arrived packet$/;"	m	class:NetworkInput	access:private
incoming	machine/console.h	/^    char incoming;    			\/\/ Contains the character to be read,$/;"	m	class:ConsoleInput	access:private
initData	userprog/noff.h	/^   Segment initData;		\/* initialized data segment *\/$/;"	m	struct:noffHeader	access:public
initdata1	test/segments.c	/^unsigned int initdata1 = 0xdeadbeef; \/* initialized data put in .data segment *\/$/;"	v
initdata2	test/segments.c	/^int initdata2 = 0xbb;                \/* same as above                         *\/$/;"	v
intLevelNames	machine/interrupt.cc	/^static char *intLevelNames[] = { "off", "on"};$/;"	v	file:
intTypeNames	machine/interrupt.cc	/^static char *intTypeNames[] = { "timer", "disk", "console write", $/;"	v	file:
interrupt	threads/kernel.h	/^    Interrupt *interrupt;	\/\/ interrupt status$/;"	m	class:Kernel	access:public
item	lib/list.h	/^    T item; 	   	     	\/\/ item on the list$/;"	m	class:ListElement	access:public
kernel	threads/main.cc	/^Kernel *kernel;$/;"	v
last	lib/list.h	/^    ListElement<T> *last;	\/\/ Last element of list$/;"	m	class:List	access:protected
lastSector	machine/disk.h	/^    int lastSector;			\/\/ The previous disk request $/;"	m	class:Disk	access:private
length	machine/network.h	/^    unsigned length;	 	\/\/ bytes of packet data, excluding the $/;"	m	class:PacketHeader	access:public
length	network/post.h	/^    unsigned length;		\/\/ Bytes of message data (excluding the $/;"	m	class:MailHeader	access:public
level	machine/interrupt.h	/^    IntStatus level;		\/\/ are interrupts enabled or disabled?$/;"	m	class:Interrupt	access:private
list	threads/synchlist.h	/^    List<T> *list;		\/\/ the list of things$/;"	m	class:SynchList	access:private
listEmpty	threads/synchlist.h	/^    Condition *listEmpty;	\/\/ wait in Remove if the list is empty$/;"	m	class:SynchList	access:private
listTestVector	lib/libtest.cc	/^static int listTestVector[] = { 9, 5, 7 };$/;"	v	file:
lock	filesys/synchdisk.h	/^    Lock *lock;		  		\/\/ Only one read\/write request$/;"	m	class:SynchDisk	access:private
lock	threads/synchlist.h	/^    Lock *lock;			\/\/ enforce mutual exclusive access to the list$/;"	m	class:SynchList	access:private
lock	userprog/synchconsole.h	/^    Lock *lock;			\/\/ only one reader at a time$/;"	m	class:SynchConsoleInput	access:private
lock	userprog/synchconsole.h	/^    Lock *lock;			\/\/ only one writer at a time$/;"	m	class:SynchConsoleOutput	access:private
lockHolder	threads/synch.h	/^    Thread *lockHolder;		\/\/ thread currently holding lock$/;"	m	class:Lock	access:private
machine	threads/kernel.h	/^    Machine *machine;           \/\/ the simulated CPU$/;"	m	class:Kernel	access:public
machineState	threads/thread.h	/^    void *machineState[MachineStateSize];  \/\/ all registers except for stackTop$/;"	m	class:Thread	access:private
mailHdr	network/post.h	/^     MailHeader mailHdr;	\/\/ Header appended by PostOffice$/;"	m	class:Mail	access:public
main	test/add.c	/^int main()$/;"	f
main	test/add2.c	/^main()$/;"	f
main	test/halt.c	/^main()$/;"	f
main	test/matmult.c	/^main()$/;"	f
main	test/segments.c	/^main()$/;"	f
main	test/shell.c	/^main()$/;"	f
main	test/sort.c	/^main()$/;"	f
main	threads/main.cc	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
mainMemory	machine/machine.h	/^    char *mainMemory;		\/\/ physical memory to store user program,$/;"	m	class:Machine	access:public
map	lib/bitmap.h	/^    unsigned int *map;		\/\/ bit storage$/;"	m	class:Bitmap	access:protected
max	lib/utility.h	21;"	d
messageAvailable	network/post.h	/^    Semaphore *messageAvailable;\/\/ V'ed when message has arrived from network$/;"	m	class:PostOfficeInput	access:private
messageSent	network/post.h	/^    Semaphore *messageSent;	\/\/ V'ed when next message can be sent to network$/;"	m	class:PostOfficeOutput	access:private
messages	network/post.h	/^    SynchList<Mail *> *messages; \/\/ A mailbox is just a list of arrived messages$/;"	m	class:MailBox	access:private
min	lib/utility.h	20;"	d
mprotect	lib/sysdep.cc	/^int mprotect(char *, unsigned int, int);$/;"	p	file:	signature:(char *, unsigned int, int)
mprotect	lib/sysdep.cc	/^int mprotect(const void *, long unsigned int, int);$/;"	p	file:	signature:(const void *, long unsigned int, int)
name	filesys/directory.h	/^    char name[FileNameMaxLen + 1];	\/\/ Text name for file, with +1 for $/;"	m	class:DirectoryEntry	access:public
name	threads/synch.h	/^    char *name;			\/\/ debugging assist$/;"	m	class:Lock	access:private
name	threads/synch.h	/^    char* name;        \/\/ useful for debugging$/;"	m	class:Semaphore	access:private
name	threads/synch.h	/^    char* name;$/;"	m	class:Condition	access:private
name	threads/thread.h	/^    char* name;$/;"	m	class:Thread	access:private
network	network/post.h	/^    NetworkInput *network;	\/\/ Physical network connection$/;"	m	class:PostOfficeInput	access:private
network	network/post.h	/^    NetworkOutput *network;	\/\/ Physical network connection$/;"	m	class:PostOfficeOutput	access:private
next	lib/list.h	/^    ListElement *next;	     	\/\/ next element on list, NULL if this is last$/;"	m	class:ListElement	access:public
noffHeader	userprog/noff.h	/^typedef struct noffHeader {$/;"	s
noffHeader::code	userprog/noff.h	/^   Segment code;		\/* executable code segment *\/ $/;"	m	struct:noffHeader	access:public
noffHeader::initData	userprog/noff.h	/^   Segment initData;		\/* initialized data segment *\/$/;"	m	struct:noffHeader	access:public
noffHeader::noffMagic	userprog/noff.h	/^   int noffMagic;		\/* should be NOFFMAGIC *\/$/;"	m	struct:noffHeader	access:public
noffHeader::readonlyData	userprog/noff.h	/^   Segment readonlyData;	\/* read only data *\/$/;"	m	struct:noffHeader	access:public
noffHeader::uninitData	userprog/noff.h	/^   Segment uninitData;		\/* uninitialized data segment --$/;"	m	struct:noffHeader	access:public
noffMagic	userprog/noff.h	/^   int noffMagic;		\/* should be NOFFMAGIC *\/$/;"	m	struct:noffHeader	access:public
numBits	lib/bitmap.h	/^    int numBits;		\/\/ number of bits in the bitmap$/;"	m	class:Bitmap	access:protected
numBoxes	network/post.h	/^    int numBoxes;		\/\/ Number of mail boxes$/;"	m	class:PostOfficeInput	access:private
numBuckets	lib/hash.h	/^    int numBuckets;		\/\/ the number of buckets$/;"	m	class:HashTable	access:private
numBytes	filesys/filehdr.h	/^    int numBytes;			\/\/ Number of bytes in the file$/;"	m	class:FileHeader	access:private
numConsoleCharsRead	machine/stats.h	/^    int numConsoleCharsRead;	\/\/ number of characters read from the keyboard$/;"	m	class:Statistics	access:public
numConsoleCharsWritten	machine/stats.h	/^    int numConsoleCharsWritten; \/\/ number of characters written to the display$/;"	m	class:Statistics	access:public
numDiskReads	machine/stats.h	/^    int numDiskReads;		\/\/ number of disk read requests$/;"	m	class:Statistics	access:public
numDiskWrites	machine/stats.h	/^    int numDiskWrites;		\/\/ number of disk write requests$/;"	m	class:Statistics	access:public
numInList	lib/list.h	/^    int numInList;		\/\/ number of elements in list$/;"	m	class:List	access:protected
numItems	lib/hash.h	/^    int numItems;		\/\/ the number of items in the table$/;"	m	class:HashTable	access:private
numPacketsRecvd	machine/stats.h	/^    int numPacketsRecvd;	\/\/ number of packets received over the network$/;"	m	class:Statistics	access:public
numPacketsSent	machine/stats.h	/^    int numPacketsSent;		\/\/ number of packets sent over the network$/;"	m	class:Statistics	access:public
numPageFaults	machine/stats.h	/^    int numPageFaults;		\/\/ number of virtual memory page faults$/;"	m	class:Statistics	access:public
numPages	userprog/addrspace.h	/^    unsigned int numPages;		\/\/ Number of pages in the virtual $/;"	m	class:AddrSpace	access:private
numSectors	filesys/filehdr.h	/^    int numSectors;			\/\/ Number of data sectors in the file$/;"	m	class:FileHeader	access:private
numWords	lib/bitmap.h	/^    int numWords;		\/\/ number of words of bitmap storage$/;"	m	class:Bitmap	access:protected
opCode	machine/mipssim.cc	/^    char opCode;     \/\/ Type of instruction.  This is NOT the same as the$/;"	m	class:Instruction	file:	access:public
opCode	machine/mipssim.h	/^    int opCode;		\/* Translated op code. *\/$/;"	m	struct:OpInfo	access:public
opStrings	machine/mipssim.h	/^static struct OpString opStrings[] = {$/;"	v	typeref:struct:OpString
opTable	machine/mipssim.h	/^static OpInfo opTable[] = {$/;"	v
packetAvail	machine/network.h	/^    bool packetAvail;		\/\/ Packet has arrived, can be pulled off of$/;"	m	class:NetworkInput	access:private
pageTable	machine/machine.h	/^    TranslationEntry *pageTable;$/;"	m	class:Machine	access:public
pageTable	userprog/addrspace.h	/^    TranslationEntry *pageTable;	\/\/ Assume linear page table translation$/;"	m	class:AddrSpace	access:private
pageTableSize	machine/machine.h	/^    unsigned int pageTableSize;$/;"	m	class:Machine	access:public
pending	machine/interrupt.h	/^    SortedList<PendingInterrupt *> *pending;		$/;"	m	class:Interrupt	access:private
physicalPage	machine/translate.h	/^    int physicalPage;  	\/\/ The page number in real memory (relative to the$/;"	m	class:TranslationEntry	access:public
ping	threads/synch.cc	/^static Semaphore *ping;$/;"	v	file:
pktHdr	network/post.h	/^     PacketHeader pktHdr;	\/\/ Header appended by Network$/;"	m	class:Mail	access:public
postOfficeIn	threads/kernel.h	/^    PostOfficeInput *postOfficeIn;$/;"	m	class:Kernel	access:public
postOfficeOut	threads/kernel.h	/^    PostOfficeOutput *postOfficeOut;$/;"	m	class:Kernel	access:public
putBusy	machine/console.h	/^    bool putBusy;    			\/\/ Is a PutChar operation in progress?$/;"	m	class:ConsoleOutput	access:private
pv	threads/switch.S	/^#define pv	$27	\/* (T)		procedure value		*\/$/;"	d
queue	threads/synch.h	/^    List<Thread *> *queue;     $/;"	m	class:Semaphore	access:private
ra	threads/switch.S	/^#define ra	$26	\/* (T)		return address		*\/$/;"	d
ra	threads/switch.S	/^#define ra      $31     \/* return address *\/$/;"	d
randomSlice	threads/kernel.h	/^    bool randomSlice;		\/\/ enable pseudo-random time slicing$/;"	m	class:Kernel	access:private
randomize	machine/timer.h	/^    bool randomize;		\/\/ set if we need to use a random timeout delay$/;"	m	class:Timer	access:private
rd	machine/mipssim.cc	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	file:	access:public
readFileNo	machine/console.h	/^    int readFileNo;			\/\/ UNIX file emulating the keyboard $/;"	m	class:ConsoleInput	access:private
readOnly	machine/translate.h	/^    bool readOnly;	\/\/ If this bit is set, the user program is not allowed$/;"	m	class:TranslationEntry	access:public
readonlyData	userprog/noff.h	/^   Segment readonlyData;	\/* read only data *\/$/;"	m	struct:noffHeader	access:public
readyList	threads/scheduler.h	/^    List<Thread *> *readyList;  \/\/ queue of threads that are ready to run,$/;"	m	class:Scheduler	access:private
recvfrom	lib/sysdep.cc	/^int recvfrom (int, void*, int, int, void*, int *);$/;"	p	file:	signature:(int, void*, int, int, void*, int *)
registers	machine/machine.h	/^    int registers[NumTotalRegs]; \/\/ CPU registers, for executing user programs$/;"	m	class:Machine	access:private
reliability	threads/kernel.h	/^    double reliability;         \/\/ likelihood messages are dropped$/;"	m	class:Kernel	access:private
rs	machine/mipssim.cc	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	file:	access:public
rt	machine/mipssim.cc	/^    char rs, rt, rd; \/\/ Three registers from instruction.$/;"	m	class:Instruction	file:	access:public
runUntilTime	machine/machine.h	/^    int runUntilTime;		\/\/ drop back into the debugger when simulated$/;"	m	class:Machine	access:private
s0	threads/switch.S	/^#define s0	$9	\/* (S)		call-safe registers	*\/$/;"	d
s0	threads/switch.S	/^#define s0      $16     \/* callee saved *\/$/;"	d
s1	threads/switch.S	/^#define s1	$10$/;"	d
s1	threads/switch.S	/^#define s1      $17$/;"	d
s2	threads/switch.S	/^#define s2	$11$/;"	d
s2	threads/switch.S	/^#define s2      $18$/;"	d
s3	threads/switch.S	/^#define s3	$12$/;"	d
s3	threads/switch.S	/^#define s3      $19$/;"	d
s4	threads/switch.S	/^#define s4	$13$/;"	d
s4	threads/switch.S	/^#define s4      $20$/;"	d
s5	threads/switch.S	/^#define s5	$14$/;"	d
s5	threads/switch.S	/^#define s5      $21$/;"	d
s6	threads/switch.S	/^#define s6	$15$/;"	d
s6	threads/switch.S	/^#define s6      $22$/;"	d
s7	threads/switch.S	/^#define s7      $23$/;"	d
scheduler	threads/kernel.h	/^    Scheduler *scheduler;	\/\/ the ready list$/;"	m	class:Kernel	access:public
sector	filesys/directory.h	/^    int sector;				\/\/ Location on disk to find the $/;"	m	class:DirectoryEntry	access:public
seekPosition	filesys/openfile.h	/^    int seekPosition;			\/\/ Current position within the file$/;"	m	class:OpenFile	access:private
segment	userprog/noff.h	/^typedef struct segment {$/;"	s
segment::inFileAddr	userprog/noff.h	/^  int inFileAddr;		\/* location of segment in this file *\/$/;"	m	struct:segment	access:public
segment::size	userprog/noff.h	/^  int size;			\/* size of segment *\/$/;"	m	struct:segment	access:public
segment::virtualAddr	userprog/noff.h	/^  int virtualAddr;		\/* location of segment in virt addr space *\/$/;"	m	struct:segment	access:public
select	lib/sysdep.cc	/^int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,$/;"	p	file:	signature:(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
select	lib/sysdep.cc	/^int select(int numBits, void *readFds, void *writeFds, void *exceptFds, $/;"	p	file:	signature:(int numBits, void *readFds, void *writeFds, void *exceptFds, struct timeval *timeout)
selfTestPing	threads/synchlist.h	/^    SynchList<T> *selfTestPing;$/;"	m	class:SynchList	access:private
semaphore	filesys/synchdisk.h	/^    Semaphore *semaphore; 		\/\/ To synchronize requesting thread $/;"	m	class:SynchDisk	access:private
semaphore	threads/synch.h	/^    Semaphore *semaphore;	\/\/ we use a semaphore to implement lock$/;"	m	class:Lock	access:private
sendBusy	machine/network.h	/^    bool sendBusy;		\/\/ Packet is being sent.$/;"	m	class:NetworkOutput	access:private
sendLock	network/post.h	/^    Lock *sendLock;		\/\/ Only one outgoing message at a time$/;"	m	class:PostOfficeOutput	access:private
sendto	lib/sysdep.cc	/^int sendto (int, const void*, int, int, void*, int);$/;"	p	file:	signature:(int, const void*, int, int, void*, int)
setStatus	machine/interrupt.h	/^    void setStatus(MachineStatus st) { status = st; }$/;"	f	class:Interrupt	access:public	signature:(MachineStatus st)
setStatus	threads/thread.h	/^    void setStatus(ThreadStatus st) { status = st; }$/;"	f	class:Thread	access:public	signature:(ThreadStatus st)
singleStep	machine/machine.h	/^    bool singleStep;		\/\/ drop back into the debugger after each$/;"	m	class:Machine	access:private
size	userprog/noff.h	/^  int size;			\/* size of segment *\/$/;"	m	struct:segment	access:public
sleep	lib/sysdep.cc	/^unsigned sleep(unsigned);$/;"	p	file:	signature:(unsigned)
sock	machine/network.h	/^    int sock;                   \/\/ UNIX socket number for incoming packets$/;"	m	class:NetworkInput	access:private
sock	machine/network.h	/^    int sock;                   \/\/ UNIX socket number for outgoing packets$/;"	m	class:NetworkOutput	access:private
sockName	machine/network.h	/^    char sockName[32];          \/\/ File name corresponding to UNIX socket$/;"	m	class:NetworkInput	access:private
socket	lib/sysdep.cc	/^int socket(int, int, int);$/;"	p	file:	signature:(int, int, int)
sp	threads/switch.S	/^#define sp	$30	\/* (S)		stack pointer		*\/$/;"	d
sp	threads/switch.S	/^#define sp      $29     \/* stack pointer *\/$/;"	d
space	threads/thread.h	/^    AddrSpace *space;			\/\/ User code this thread is running.$/;"	m	class:Thread	access:public
specialTable	machine/mipssim.h	/^static int specialTable[] = {$/;"	v
stack	threads/thread.h	/^    int *stack; 	 	\/\/ Bottom of the stack $/;"	m	class:Thread	access:private
stackTop	threads/thread.h	/^    int *stackTop;			 \/\/ the current stack pointer$/;"	m	class:Thread	access:private
stats	threads/kernel.h	/^    Statistics *stats;		\/\/ performance metrics$/;"	m	class:Kernel	access:public
status	machine/interrupt.h	/^    MachineStatus status;	\/\/ idle, kernel mode, user mode$/;"	m	class:Interrupt	access:private
status	threads/thread.h	/^    ThreadStatus status;	\/\/ ready, running or blocked$/;"	m	class:Thread	access:private
synchConsoleIn	threads/kernel.h	/^    SynchConsoleInput *synchConsoleIn;$/;"	m	class:Kernel	access:public
synchConsoleOut	threads/kernel.h	/^    SynchConsoleOutput *synchConsoleOut;$/;"	m	class:Kernel	access:public
synchDisk	threads/kernel.h	/^    SynchDisk *synchDisk;$/;"	m	class:Kernel	access:public
systemTicks	machine/stats.h	/^    int systemTicks;	 	\/\/ Time spent executing system code$/;"	m	class:Statistics	access:public
t0	threads/switch.S	/^#define t0	$1	\/* (T)		temporary registers	*\/$/;"	d
table	filesys/directory.h	/^    DirectoryEntry *table;		\/\/ Table of pairs: $/;"	m	class:Directory	access:private
table	lib/hash.h	/^    HashTable<Key,T> *table;	\/\/ the hash table we're stepping through$/;"	m	class:HashIterator	access:private
tableSize	filesys/directory.h	/^    int tableSize;			\/\/ Number of directory entries$/;"	m	class:Directory	access:private
tell	lib/sysdep.cc	/^long tell(int);$/;"	p	file:	signature:(int)
timer	threads/alarm.h	/^    Timer *timer;		\/\/ the hardware timer device$/;"	m	class:Alarm	access:private
tlb	machine/machine.h	/^    TranslationEntry *tlb;		\/\/ this pointer should be considered $/;"	m	class:Machine	access:public
to	machine/network.h	/^    NetworkAddress to;		\/\/ Destination machine ID$/;"	m	class:PacketHeader	access:public
to	network/post.h	/^    MailBoxAddress to;		\/\/ Destination mail box$/;"	m	class:MailHeader	access:public
toBeDestroyed	threads/scheduler.h	/^    Thread *toBeDestroyed;	\/\/ finishing thread to be destroyed$/;"	m	class:Scheduler	access:private
totalTicks	machine/stats.h	/^    int totalTicks;      	\/\/ Total time running Nachos$/;"	m	class:Statistics	access:public
type	machine/interrupt.h	/^    IntType type;		\/\/ for debugging$/;"	m	class:PendingInterrupt	access:public
uninitData	userprog/noff.h	/^   Segment uninitData;		\/* uninitialized data segment --$/;"	m	struct:noffHeader	access:public
uninitdata	test/segments.c	/^int uninitdata[N];                   \/* allocate space in .bss segment        *\/$/;"	v
use	machine/translate.h	/^    bool use;           \/\/ This bit is set by the hardware every time the$/;"	m	class:TranslationEntry	access:public
userRegisters	threads/thread.h	/^    int userRegisters[NumTotalRegs];	\/\/ user-level CPU register state$/;"	m	class:Thread	access:private
userTicks	machine/stats.h	/^    int userTicks;       	\/\/ Time spent executing user code$/;"	m	class:Statistics	access:public
v0	threads/switch.S	/^#define	v0	$0	\/* (T)		return value		*\/$/;"	d
valid	machine/translate.h	/^    bool valid;         \/\/ If this bit is set, the translation is ignored.$/;"	m	class:TranslationEntry	access:public
value	machine/mipssim.cc	/^    unsigned int value; \/\/ binary representation of the instruction$/;"	m	class:Instruction	file:	access:public
value	threads/synch.h	/^    int value;         \/\/ semaphore value, always >= 0$/;"	m	class:Semaphore	access:private
virtualAddr	userprog/noff.h	/^  int virtualAddr;		\/* location of segment in virt addr space *\/$/;"	m	struct:segment	access:public
virtualPage	machine/translate.h	/^    int virtualPage;  	\/\/ The page number in virtual memory.$/;"	m	class:TranslationEntry	access:public
waitFor	userprog/synchconsole.h	/^    Semaphore *waitFor;		\/\/ wait for callBack$/;"	m	class:SynchConsoleInput	access:private
waitFor	userprog/synchconsole.h	/^    Semaphore *waitFor;		\/\/ wait for callBack$/;"	m	class:SynchConsoleOutput	access:private
waitQueue	threads/synch.h	/^    List<Semaphore *> *waitQueue;	\/\/ list of waiting threads$/;"	m	class:Condition	access:private
when	machine/interrupt.h	/^    int when;			\/\/ When the interrupt is supposed to fire$/;"	m	class:PendingInterrupt	access:public
writeFileNo	machine/console.h	/^    int writeFileNo;			\/\/ UNIX file emulating the display$/;"	m	class:ConsoleOutput	access:private
yieldOnReturn	machine/interrupt.h	/^    bool yieldOnReturn; 	\/\/ TRUE if we are to context switch$/;"	m	class:Interrupt	access:private
z	threads/switch.S	/^#define z       $0      \/* zero register *\/$/;"	d
zero	threads/switch.S	/^#define zero	$31	\/* 		wired zero		*\/$/;"	d
~AddrSpace	userprog/addrspace.cc	/^AddrSpace::~AddrSpace()$/;"	f	class:AddrSpace	signature:()
~AddrSpace	userprog/addrspace.h	/^    ~AddrSpace();			\/\/ De-allocate an address space$/;"	p	class:AddrSpace	access:public	signature:()
~Alarm	threads/alarm.h	/^    ~Alarm() { delete timer; }$/;"	f	class:Alarm	access:public	signature:()
~Bitmap	lib/bitmap.cc	/^Bitmap::~Bitmap()$/;"	f	class:Bitmap	signature:()
~Bitmap	lib/bitmap.h	/^    ~Bitmap();			\/\/ De-allocate bitmap$/;"	p	class:Bitmap	access:public	signature:()
~CallBackObj	machine/callback.h	/^     virtual ~CallBackObj() {};$/;"	f	class:CallBackObj	access:protected	signature:()
~Condition	threads/synch.cc	/^Condition::~Condition()$/;"	f	class:Condition	signature:()
~Condition	threads/synch.h	/^    ~Condition();			\/\/ deallocate the condition$/;"	p	class:Condition	access:public	signature:()
~ConsoleInput	machine/console.cc	/^ConsoleInput::~ConsoleInput()$/;"	f	class:ConsoleInput	signature:()
~ConsoleInput	machine/console.h	/^    ~ConsoleInput();		\/\/ clean up console emulation$/;"	p	class:ConsoleInput	access:public	signature:()
~ConsoleOutput	machine/console.cc	/^ConsoleOutput::~ConsoleOutput()$/;"	f	class:ConsoleOutput	signature:()
~ConsoleOutput	machine/console.h	/^    ~ConsoleOutput();		\/\/ clean up console emulation$/;"	p	class:ConsoleOutput	access:public	signature:()
~Directory	filesys/directory.cc	/^Directory::~Directory()$/;"	f	class:Directory	signature:()
~Directory	filesys/directory.h	/^    ~Directory();			\/\/ De-allocate the directory$/;"	p	class:Directory	access:public	signature:()
~Disk	machine/disk.cc	/^Disk::~Disk()$/;"	f	class:Disk	signature:()
~Disk	machine/disk.h	/^    ~Disk();				\/\/ Deallocate the disk.$/;"	p	class:Disk	access:public	signature:()
~HashIterator	lib/hash.h	/^    ~HashIterator() { if (bucketIter != NULL) delete bucketIter;}; $/;"	f	class:HashIterator	access:public	signature:()
~HashTable	lib/hash.cc	/^HashTable<Key,T>::~HashTable()$/;"	f	class:HashTable	signature:()
~HashTable	lib/hash.h	/^    ~HashTable();		\/\/ deallocate a hash table$/;"	p	class:HashTable	access:public	signature:()
~Interrupt	machine/interrupt.cc	/^Interrupt::~Interrupt()$/;"	f	class:Interrupt	signature:()
~Interrupt	machine/interrupt.h	/^    ~Interrupt();		\/\/ de-allocate data structures$/;"	p	class:Interrupt	access:public	signature:()
~Kernel	threads/kernel.cc	/^Kernel::~Kernel()$/;"	f	class:Kernel	signature:()
~Kernel	threads/kernel.h	/^    ~Kernel();		        \/\/ deallocate the kernel$/;"	p	class:Kernel	access:public	signature:()
~List	lib/list.cc	/^List<T>::~List()$/;"	f	class:List	signature:()
~List	lib/list.h	/^    virtual ~List();		\/\/ de-allocate the list$/;"	p	class:List	access:public	signature:()
~Lock	threads/synch.cc	/^Lock::~Lock()$/;"	f	class:Lock	signature:()
~Lock	threads/synch.h	/^    ~Lock();			\/\/ deallocate lock$/;"	p	class:Lock	access:public	signature:()
~Machine	machine/machine.cc	/^Machine::~Machine()$/;"	f	class:Machine	signature:()
~Machine	machine/machine.h	/^    ~Machine();			\/\/ De-allocate the data structures$/;"	p	class:Machine	access:public	signature:()
~MailBox	network/post.cc	/^MailBox::~MailBox()$/;"	f	class:MailBox	signature:()
~MailBox	network/post.h	/^    ~MailBox();			\/\/ De-allocate mail box$/;"	p	class:MailBox	access:public	signature:()
~NetworkInput	machine/network.cc	/^NetworkInput::~NetworkInput()$/;"	f	class:NetworkInput	signature:()
~NetworkInput	machine/network.h	/^    ~NetworkInput();		\/\/ De-allocate the network input driver data$/;"	p	class:NetworkInput	access:public	signature:()
~NetworkOutput	machine/network.cc	/^NetworkOutput::~NetworkOutput()$/;"	f	class:NetworkOutput	signature:()
~NetworkOutput	machine/network.h	/^    ~NetworkOutput();		\/\/ De-allocate the network input driver data$/;"	p	class:NetworkOutput	access:public	signature:()
~OpenFile	filesys/openfile.cc	/^OpenFile::~OpenFile()$/;"	f	class:OpenFile	signature:()
~OpenFile	filesys/openfile.h	/^    ~OpenFile() { Close(file); }			\/\/ close the file$/;"	f	class:OpenFile	access:public	signature:()
~OpenFile	filesys/openfile.h	/^    ~OpenFile();			\/\/ Close the file$/;"	p	class:OpenFile	access:public	signature:()
~PersistentBitmap	filesys/pbitmap.cc	/^PersistentBitmap::~PersistentBitmap()$/;"	f	class:PersistentBitmap	signature:()
~PersistentBitmap	filesys/pbitmap.h	/^    ~PersistentBitmap(); 			\/\/ deallocate bitmap$/;"	p	class:PersistentBitmap	access:public	signature:()
~PostOfficeInput	network/post.cc	/^PostOfficeInput::~PostOfficeInput()$/;"	f	class:PostOfficeInput	signature:()
~PostOfficeInput	network/post.h	/^    ~PostOfficeInput();		\/\/ De-allocate Post Office data$/;"	p	class:PostOfficeInput	access:public	signature:()
~PostOfficeOutput	network/post.cc	/^PostOfficeOutput::~PostOfficeOutput()$/;"	f	class:PostOfficeOutput	signature:()
~PostOfficeOutput	network/post.h	/^    ~PostOfficeOutput();	\/\/ De-allocate Post Office data$/;"	p	class:PostOfficeOutput	access:public	signature:()
~Scheduler	threads/scheduler.cc	/^Scheduler::~Scheduler()$/;"	f	class:Scheduler	signature:()
~Scheduler	threads/scheduler.h	/^    ~Scheduler();		\/\/ De-allocate ready list$/;"	p	class:Scheduler	access:public	signature:()
~Semaphore	threads/synch.cc	/^Semaphore::~Semaphore()$/;"	f	class:Semaphore	signature:()
~Semaphore	threads/synch.h	/^    ~Semaphore();   					\/\/ de-allocate semaphore$/;"	p	class:Semaphore	access:public	signature:()
~SortedList	lib/list.h	/^    ~SortedList() {};		\/\/ base class destructor called automatically$/;"	f	class:SortedList	access:public	signature:()
~SynchConsoleInput	userprog/synchconsole.cc	/^SynchConsoleInput::~SynchConsoleInput()$/;"	f	class:SynchConsoleInput	signature:()
~SynchConsoleInput	userprog/synchconsole.h	/^    ~SynchConsoleInput();		\/\/ Deallocate console device$/;"	p	class:SynchConsoleInput	access:public	signature:()
~SynchConsoleOutput	userprog/synchconsole.cc	/^SynchConsoleOutput::~SynchConsoleOutput()$/;"	f	class:SynchConsoleOutput	signature:()
~SynchConsoleOutput	userprog/synchconsole.h	/^    ~SynchConsoleOutput();$/;"	p	class:SynchConsoleOutput	access:public	signature:()
~SynchDisk	filesys/synchdisk.cc	/^SynchDisk::~SynchDisk()$/;"	f	class:SynchDisk	signature:()
~SynchDisk	filesys/synchdisk.h	/^    ~SynchDisk();			\/\/ De-allocate the synch disk data$/;"	p	class:SynchDisk	access:public	signature:()
~SynchList	threads/synchlist.cc	/^SynchList<T>::~SynchList()$/;"	f	class:SynchList	signature:()
~SynchList	threads/synchlist.h	/^    ~SynchList();		\/\/ de-allocate a synchronized list$/;"	p	class:SynchList	access:public	signature:()
~Thread	threads/thread.cc	/^Thread::~Thread()$/;"	f	class:Thread	signature:()
~Thread	threads/thread.h	/^    ~Thread(); 				\/\/ deallocate a Thread$/;"	p	class:Thread	access:public	signature:()
~Timer	machine/timer.h	/^    virtual ~Timer() {}$/;"	f	class:Timer	access:public	signature:()
